# -*- coding: utf-8 -*-
"""ESTUDO PYTHON VITOR COLAB

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M7kfrDtZcSIIRjt1Hm3bAHa0S7iEOHPb

CÓDIGO PROJETO VITOR CADASTRO DE PRODUTOS
"""

!pip install pyodbc
!pip install tkinter
#Importa o Módulo para a conexão com o BD
import pyodbc

#Importa o módulo para interface gráfica
from tkinter import *

#Importa classes ttk do módulo tkinter
from tkinter import ttk

#Função que verifica se login e senha estão corretos
def verifica_credenciais():
    # Drive - drive
    # Server - servidor
    # Database - nome do banco de dados
    conexao = pyodbc.connect("Driver={SQLite3 ODBC Driver};Server=localhost;Database=Projeto_Compras.db")

    # Responsável por executar os códigos SQL
    cursor = conexao.cursor()

    # Query para selecionar usuários que possuem o nome de usuários e senhas inseridos pelo mesmo
    cursor.execute("SELECT * FROM Usuários WHERE Nome = ? AND Senha = ?", (nome_usuario_entry.get(), senha_usuario_entry.get()))

    usuario = cursor.fetchone()

    if usuario:
        # Fechar janela de login caso o usuário exista no BD (senha e usuário corretos)
        janela_principal.destroy()

        # Conexão com o banco de dados
        dadosConexao = ("Driver={SQLite3 ODBC Driver};Server=localhost;Database=Projeto_Compras.db")

        conexao = pyodbc.connect(dadosConexao)

        # Cria objeto cursor para executar comandos SQL no banco de dados
        cursor = conexao.cursor()

        # Seleciona a tabela de Produtos
        conexao.execute("SELECT * FROM Produtos")

        print("Conectado com sucesso!")

        def listar_dados():
            # Limpa os valores da treeview
            for i in treeview.get_children():
                treeview.delete(i)

            # Seleciona a tabela de Produtos
            cursor.execute("SELECT * FROM Produtos")

            # Armazena os valores retornados pelo comando SQL em uma variável
            valores = cursor.fetchall()

            # Adiciona os valores na treeview
            for valor in valores:
                # Popula linha por linha
                treeview.insert("", "end", values=(valor[0], valor[1], valor[2], valor[3]))


        # Cria uma janela tkinter para cadastro de produtos
        janela = Tk()
        janela.title("Cadastro de Produtos")
        janela.configure(bg="#D3D3D3")
        janela.attributes("-fullscreen", True)

        Label(janela, text="Nome do Produto: ", font=("Arial", 12, "bold"), bg="#F5F5F5").grid(row=0, column=2, padx=10, pady=10)
        nome_produto = Entry(janela, font="Arial 14")
        nome_produto.grid(row=0, column=3, padx=10, pady=10)

        Label(janela, text="Descrição do Produto: ", font=("Arial", 12, "bold"), bg="#F5F5F5").grid(row=0, column=5, padx=10, pady=10)
        descricao_produto = Entry(janela, font="Arial 14")
        descricao_produto.grid(row=0, column=6, padx=10, pady=10)

        Label(janela, text="Produtos", font="Arial 12", fg="blue", bg="#F5F5F5").grid(row=2, column=0, columnspan=10, padx=10, pady=10)

        # Função de cadastro do produto
        def cadastrar():

            def salvar_dados():
                # Obtém os valores inseridos nos campos de entrada
                novo_produto_cadastrar = (nome_produto_cadastrar.get(), descricao_produto_cadastrar.get(), preco_produto_cadastrar.get())

                # Executa um comando SQL para inserir os valores na tabela Produtos
                cursor.execute("INSERT INTO Produtos (NomeProduto, Descricao, Preco) VALUES (?, ?, ?)", novo_produto_cadastrar)

                # Realiza o commit da transação para salvar as alterações no banco de dados
                conexao.commit()
                print("Dados Cadastrados com sucesso!")

                # Fecha a janela de cadastro
                janela_cadastrar.destroy()

                #Chama a função para listar o BD
                listar_dados()


            # Cria uma nova janela para o cadastro de produtos
            janela_cadastrar = Toplevel(janela)
            janela_cadastrar.title("Cadastrar Produto")
            janela_cadastrar.configure(bg="#FFFFFF")

            # Define as dimensões e posição da janela de cadastro
            largura_janela = 400
            altura_janela = 225
            largura_tela = janela_cadastrar.winfo_screenwidth()
            altura_tela = janela_cadastrar.winfo_screenheight()  # Corrigido para obter a altura correta da tela
            pos_x = (largura_tela // 2) - (largura_janela // 2)
            pos_y = (altura_tela // 2) - (altura_janela // 2)  # Corrigido para calcular a posição y correta
            janela_cadastrar.geometry('{}x{}+{}+{}'.format(largura_janela, altura_janela, pos_x, pos_y))

            for i in range(5):
                janela_cadastrar.grid_rowconfigure(i, weight=1)

            #Aqui se faz o mesmo que o comentário acima, porém para as colunas.
            for i in range(5):
                janela_cadastrar.grid_columnconfigure(i, weight=1)

            estilo_borda = {"borderwidth": 2, "relief": "groove"}

            # Criação dos rótulos e campos de entrada na janela de cadastro
            Label(janela_cadastrar, text="Nome do Produto:", font=("Arial", 12), bg="#FFFFFF").grid(row=0, column=0, padx=10, pady=10, sticky="W")
            nome_produto_cadastrar = Entry(janela_cadastrar, font=("Arial", 12), **estilo_borda)
            nome_produto_cadastrar.grid(row=0, column=1, padx=10, pady=10)

            Label(janela_cadastrar, text="Descrição do Produto:", font=("Arial", 12), bg="#FFFFFF").grid(row=1, column=0, padx=10, pady=10, sticky="W")
            descricao_produto_cadastrar = Entry(janela_cadastrar, font=("Arial", 12), **estilo_borda)
            descricao_produto_cadastrar.grid(row=1, column=1, padx=10, pady=10)

            Label(janela_cadastrar, text="Preço do Produto:", font=("Arial", 12), bg="#FFFFFF").grid(row=2, column=0, padx=10, pady=10, sticky="W")
            preco_produto_cadastrar = Entry(janela_cadastrar, font=("Arial", 12), **estilo_borda)
            preco_produto_cadastrar.grid(row=2, column=1, padx=10, pady=10)

            botao_salvar_dados = Button(janela_cadastrar, text="Salvar", font=("Arial", 12), command=salvar_dados)
            botao_salvar_dados.grid(row=3, column=0, columnspan=2, padx=10, pady=10, sticky="NSEW")

            botao_cancelar = Button(janela_cadastrar, text="Cancelar", font=("Arial", 12), command=janela_cadastrar.destroy)
            botao_cancelar.grid(row=4, column=0, columnspan=2, padx=10, pady=10, stick="NSEW")

        #Cria Botão para gravar os dados na tabela Produtos do BD
        botao_gravar = Button(janela, text="Novo", command=cadastrar, font="Arial 12")
        botao_gravar.grid(row=4, column=0, columnspan=4, stick="NSEW", padx=80, pady=1)



        #Define o estilo da treeview
        style = ttk.Style(janela)


        # Cria a treeview
        treeview = ttk.Treeview(janela, style="mystyle.Treeview")

        style.theme_use("default")

        style.configure("mystyle.Treeview", font=("Arial", 12))

        treeview = ttk.Treeview(janela, style="mystyle.Treeview", columns=("ID", "NomeProduto", "Descricao", "Preco"), show="headings", height=20)

        treeview.heading("ID", text="ID")
        treeview.heading("NomeProduto", text="Nome do Produto")
        treeview.heading("Descricao", text="Descrição do Produto")
        treeview.heading("Preco", text="Preço do Produto")

        #A primeira coluna identificada como "#0"
        #A opção "strech=NO" indica que a coluna não deve esticar para preencher o espaço.
        treeview.column("#0", width=0, stretch=NO) #coluna invisível
        treeview.column("ID", width=100)
        treeview.column("NomeProduto", width=300)
        treeview.column("Descricao", width=400)
        treeview.column("Preco", width=180)

        treeview.grid(row=3, column=0, columnspan=10, stick="NSEW")

        #Chama a função para listar o BD
        listar_dados()

        def editar_dados(event):

            #Obtém o item selecionado na treeview
            item_selecionado = treeview.selection()[0]

            valores_selecionados = treeview.item(item_selecionado)['values']

             # Cria uma nova janela para o cadastro de produtos
            janela_edicao = Toplevel(janela)
            janela_edicao.title("Editar Produto")
            janela_edicao.configure(bg="#FFFFFF")

            # Define as dimensões e posição da janela de cadastro
            largura_janela = 500
            altura_janela = 200
            largura_tela = janela_edicao.winfo_screenwidth()
            altura_tela = janela_edicao.winfo_screenheight()  # Corrigido para obter a altura correta da tela
            pos_x = (largura_tela // 2) - (largura_janela // 2)
            pos_y = (altura_tela // 2) - (altura_janela // 2)  # Corrigido para calcular a posição y correta
            janela_edicao.geometry('{}x{}+{}+{}'.format(largura_janela, altura_janela, pos_x, pos_y))

            for i in range(5):
                janela_edicao.grid_rowconfigure(i, weight=1)

            #Aqui se faz o mesmo que o comentário acima, porém para as colunas.
            for i in range(2):
                janela_edicao.grid_columnconfigure(i, weight=1)

            estilo_borda = {"borderwidth": 2, "relief": "groove"}

            # Criação dos rótulos e campos de entrada na janela de cadastro
            Label(janela_edicao, text="Nome do Produto:", font=("Arial", 12), bg="#FFFFFF").grid(row=0, column=0, padx=10, pady=10, sticky="W")
            nome_produto_edicao = Entry(janela_edicao, font=("Arial", 12), **estilo_borda, bg="#FFFFFF", textvariable=StringVar(value=valores_selecionados[1]))
            nome_produto_edicao.grid(row=0, column=1, padx=10, pady=10)

            Label(janela_edicao, text="Descrição do Produto:", font=("Arial", 12), bg="#FFFFFF").grid(row=1, column=0, padx=10, pady=10, sticky="W")
            descricao_produto_edicao = Entry(janela_edicao, font=("Arial", 12), **estilo_borda, bg="#FFFFFF", textvariable=StringVar(value=valores_selecionados[2]))
            descricao_produto_edicao.grid(row=1, column=1, padx=10, pady=10)

            Label(janela_edicao, text="Preço do Produto:", font=("Arial", 12), bg="#FFFFFF").grid(row=2, column=0, padx=10, pady=10, sticky="W")
            preco_produto_edicao = Entry(janela_edicao, font=("Arial", 12), **estilo_borda, bg="#FFFFFF", textvariable=StringVar(value=valores_selecionados[3]))
            preco_produto_edicao.grid(row=2, column=1, padx=10, pady=10)


            def salvar_edicao():

                # Obtém os novos valores do item selecionado na treeview
                novo_produto = nome_produto_edicao.get()
                nova_descricao = descricao_produto_edicao.get()
                novo_preco = preco_produto_edicao.get()

                # Atualiza os valores do item selecionado
                valores_selecionados[1] = novo_produto
                valores_selecionados[2] = nova_descricao
                valores_selecionados[3] = novo_preco
                treeview.item(item_selecionado, values=valores_selecionados)

                # Executa um comando SQL para atualizar os valores na tabela Produtos
                cursor.execute("UPDATE Produtos SET NomeProduto = ?, Descricao = ?, Preco = ? WHERE ID = ?", (novo_produto, nova_descricao, novo_preco, valores_selecionados[0]))

                # Realiza o commit da transação para salvar as alterações no banco de dados
                conexao.commit()
                print("Dados alterados com sucesso!")

                # Fecha a janela de cadastro
                janela_edicao.destroy()

                # Chama a função para listar o BD
                listar_dados()

            def deletar_registro():

                #Recupera o id do registro selecionado na treeview
                selected_item = treeview.selection()[0]
                id = treeview.item(selected_item)['values'][0]

                #Deleta o registro do BD
                cursor.execute("DELETE FROM PRODUTOS WHERE id = ?", (id,))

                conexao.commit()

                #Fecha a janela de edição
                janela_edicao.destroy()

                #Recarregar os dados sem o novo registro
                listar_dados()




            botao_salvar_edicao = Button(janela_edicao, text="Alterar", font=("Arial", 12), bg="#008000", fg="#FFFFFF", command=salvar_edicao)
            botao_salvar_edicao.grid(row=4, column=0, padx=20, pady=20)

            botao_deletar_edicao = Button(janela_edicao, text="Deletar", font=("Arial", 12), bg="#FF0000", fg="#FFFFFF", command=deletar_registro)
            botao_deletar_edicao.grid(row=4, column=1, padx=20, pady=20)


        #Chama a função editar dados ao dar duplo clique na treeview
        treeview.bind("<Double-1>", editar_dados)


        menu_barra = Menu(janela)
        janela.configure(menu=menu_barra)

        menu_arquivo = Menu(menu_barra, tearoff=0)
        menu_barra.add_cascade(label="Arquivo", menu=menu_arquivo)

        menu_arquivo.add_command(label="Cadastrar", command=cadastrar)
        menu_arquivo.add_command(label="Sair", command=janela.destroy)



        ''' Concatena a string 'sql' com a cláusula SQL "WHERE NomeProduto LIKE ?". Essa cláusula é usada para filtrar
        resultados de uma consulta de BD com base em um padrão de correspondência de texto, representado pelo carctere
        coringa "?" na cláusula "LIKE". Em resumo, esta linha está adicionando uma condição de filtro à consulta SQL
        para buscar registros que tenham o campo 'nome_produto' correspondente ao padrão especificado.'''


        def limparDados():

            #Limpando os valores(dados) da treeview
            for linha in treeview.get_children():

                #Deleta linha por linha da treeview
                treeview.delete(linha)

        def filtrar_dados(nome_produto, descricao_produto):

            #Verifica se os campos estão vazios
            if not nome_produto.get() and not descricao_produto.get():

                listar_dados()

                #Se os campos estiverem vazios, não faz nada
                return

            sql = "SELECT * FROM Produtos"

            params = []

            '''Associa um evento que libera a tecla "KeyRelease", ao widget de entrada de texto
        chamado nome_produto. Quando o evento de liberação de tecla ocorrer, a função lambda
        definida será executada. Essa função lambda recebe um objeto de evento (geralmente abreviado com 'e')
        como seu argumento e chama uma outra função chamada "filtrar_dados". A função "filtrar_dados" é passada
        como argumento aos widgets "nome_produto" e "descricao_produto". O objetivo dessa linha de código é permitir ao
        usuário que filtre os dados mostrados no programa com base no que foi digitadono campo "nome_produto". Quando
        o usuário digita algo no campo "nome_produo" e solta a tecla, a função "filtrar_dados" é chamada para atualizar
        a exibição dos dados de acordo com o que foi digitado.'''

            if nome_produto.get():

                '''Adiciona um parâmetro à lista params. Esse parâmetro é uma string composta por 3 partes concatenadas:
                1 - O caractere coringa '%' no início da string, que representa qualquer número de (ou nenhum) antes do padrão
                de correspondência de texto.
                2-O valor do campo 'nome_produto' (obtido com o método 'get()' do widget de entrada de texto correspondente).
                3-Outro caractere coringa "%" no final da string, que representa qualquer número de caracteres (ou nenhum)
                depois do padrão de correspondência de texto. Essa string será usada como o valor do parâmetro da clausula 'LIKE'
                da consulta SQL, permitindo que a consulta retorne registros que tenham o campo 'NomeProduto' correspondente
                ao padrão especificado pelo usuário na interface do programa. Em resumo essa linha de código está criando um
                parâmetro de consulta dinamicamente com base no texto digitado pelo usuário e adicionando-o à lista de
                parâmetros que serão usados na consulta SQL.
                '''
                sql += " WHERE NomeProduto LIKE ?"
                params.append('%' + nome_produto.get() + '%')

            '''Verifica se o campo de entrada de texto 'descricao_produto' tem alguma valor preenchido. Caso tenha,
            ele adiciona uma cláusula SQL adicional à consulta em andamento para filtrar os resultados com base
            em um padrão de correspondência de texto na coluna 'Descricao'. Se o campo 'nome_produto' também tiver
            um valor preenchido, é adicionada uma cláusula 'AND' para juntar as duas condições de filtro. Caso contrário,
            é adicionada a cláusula 'WHERE' para começar a filtrar diretamente pela coluna 'Descricao'. A linha params.append,
            cria um parâmetro de consulta dinamicamente com base no texto digitado pelo usuário no campo 'descricao_produto'
            permitindo que o usuário filtre os resultados com base em dois campos diferentes ('NomeProduto' e 'Descricao') ao
            mesmo tempo, caso estejam preenchidos'''


            if descricao_produto.get():

                if nome_produto.get():
                    sql += " AND"
                else:
                    sql += " WHERE"

                sql += " Descricao LIKE ?"
                params.append('%' + descricao_produto.get() + '%')

            cursor.execute(sql, tuple(params))
            produtos = cursor.fetchall()

            #Lipa os dados da treeview
            limparDados()

            #Preenche treeview com os dados filtrados
            for dado in produtos:

                treeview.insert('', 'end', values=(dado[0], dado[1], dado[2], dado[3]))

        nome_produto.bind("<KeyRelease>", lambda e: filtrar_dados(nome_produto, descricao_produto))
        descricao_produto.bind("<KeyRelease>", lambda e: filtrar_dados(nome_produto, descricao_produto))

        #Deleta o registro
        def deletar():

            #Recupera o id do registro selecionado na treeview
            selected_item = treeview.selection()[0]
            id = treeview.item(selected_item)['values'][0]

            #Deleta o registro do BD
            cursor.execute("DELETE FROM PRODUTOS WHERE id = ?", (id,))

            conexao.commit()

            #Recarregar os dados sem o novo registro
            listar_dados()

        #Cria Botão para gravar os dados na tabela Produtos do BD
        botao_deletar = Button(janela, text="Deletar", command=deletar, font="Arial 12")
        botao_deletar.grid(row=4, column=4, columnspan=4, stick="NSEW", padx=80, pady=1)


        janela.mainloop()

        # Fecha o cursor e a conexão com o banco de dados
        cursor.close()
        conexao.close()

    else:
        mensagem_lbl = Label(janela_principal, text="Nome de usuário ou senha incorretos", fg="red")
        mensagem_lbl.grid(row=3, column=0, columnspan=2)

#Criando a tela principal para a tela de login
janela_principal = Tk()
janela_principal.title("Tela de Login")


#bg = background plano de fundo
janela_principal.configure(bg="#F5F5F5")

#Define altura e largura da janela(ficam fixas)
largura_janela = 450
altura_janela = 300

#Obtém a largura e altura da tela do computador
largura_tela = janela_principal.winfo_screenwidth()
altura_tela = janela_principal.winfo_screenwidth()


''' Essas linhas calculam a posição em que a janela deve ser exibida
centralizada na tela do computador. A posição x é definida pela
diferença entre a largura da tela e a largura da janela, dividida por 2
Já a posição y é definida pela diferença entre a altura da tela e a altura da janela,
também dividia por 2 '''

#Calcula a posição da janela para centralizá-la na tela
pos_x = (largura_tela // 2) - (largura_janela // 2)
pos_y = (largura_tela // 2) - (largura_janela // 2)

'''define a geometria da janela principal, especificando a largura e a altura da janela,
bem como a posição onde a janela será exibida na tela, usando as variáveis previamente definidas
para a posição x e y da janela. O formato utilizado é uma string que contém os valores da largura,
altura, posição x e posição y da janela separados por "x" e "+" e passados como argumentospara o
método geometry() da janela principal.

O formato  {}x{}+{}+{}' é uma string de formatação que espera quatro valores, que correspondem
à largura da janela, altura da janela, posição x da janela e posição y da janela, respectivamente.

Esses valores são passados na ordem especificada para a string de formatação e, em seguida,
são utilizados para definir a geometria da janela através do método geometry() do objeto
janela_principal'''

#Define a posição da janela
janela_principal.geometry('{}x{}+{}+{}'.format(largura_janela, altura_janela, pos_x, pos_y))

#Configurações de cor da letra (fg - foreground), fonte e texto
titulo_lbl = Label(janela_principal, text="Tela de Login", font="Arial 20", fg="blue", bg="#F5F5F5")
#Método que divide como se fosse uma tabela em partes
#row(linhas) - column(coluna), columnspan (quantas colunas vai ocupar no grid), pady (espaço quevai ocupar)
titulo_lbl.grid(row=0, column=0, columnspan=2, pady=20)


#Campo Label
nome_usuario_lbl = Label(janela_principal, text="Senha", font="Arial 14 bold", bg="#F5F5F5")
nome_usuario_lbl.grid(row=2, column=0, stick="e")#NSEW

#Campo Label
senha_usuario_lbl = Label(janela_principal, text="Nome de Usuário", font="Arial 14 bold", bg="#F5F5F5")
senha_usuario_lbl.grid(row=1, column=0, stick="e")#NSEW


#Criando um entry para o campo usuário
nome_usuario_entry = Entry(janela_principal, font="Arial 14")
nome_usuario_entry.grid(row=1, column=1, pady=10)


#Criando um entry para o campo usuário
senha_usuario_entry = Entry(janela_principal, show="*", font="Arial 14")
senha_usuario_entry.grid(row=2, column=1, pady=10)

#Stick preenche as laterais -NSEW (North, South, East, West)
entrar_btn = Button(janela_principal, text="Entrar", font="Arial 14", command=verifica_credenciais)
entrar_btn.grid(row=4, column=0, columnspan=2, padx=20, pady=10, stick="NSEW")

#Stick preenche as laterais -NSEW (North, South, East, West)
sair_btn = Button(janela_principal, text="Sair", font="Arial 14", command=janela_principal.destroy)
sair_btn.grid(row=5, column=0, columnspan=2, padx=20, pady=10, stick="NSEW")

''' Laço for que executa 5 vezes e serve para configurar o comportamento de uma grade (ou grid)
no tkinter. A função grid_rowconfigure() permite definir a configuração de uma determinada linha na
grade, com dois parâmetros: o índice da linha e um peso (weight) que determina como essa linha
deve se comportar em relação às outras linhas da grade. No código em questão, o laço for está
configurando as 5 linhas da grade da janela_principal com um peso igual a 1. Isso significa que
todas as linhas terão a mesma altura e que a altura da janela será dividida igualmente entre elas.
'''
for i in range(5):
    janela_principal.grid_rowconfigure(i, weight=1)

#Aqui se faz o mesmo que o comentário acima, porém para as colunas.
for i in range(5):
    janela_principal.grid_columnconfigure(i, weight=1)

#inicia a janela do tkinter
janela_principal.mainloop()

import os
from telegram import Update
from telegram.ext import Updater, CommandHandler, CallbackContext

# Function to handle the /downloadall command
def download_all(update: Update, context: CallbackContext):
    # ID of the channel you want to download files from
    channel_id = -1170686803  # Replace with the correct channel ID

    # Retrieve the channel
    chat = context.bot.get_chat(channel_id)
    if not chat:
        update.message.reply_text("Channel not found: {}".format(channel_id))
        return

    # Get the channel's messages
    messages = context.bot.get_chat(chat_id=channel_id).get("messages", [])

    # Check if there are messages in the channel
    if not messages:
        update.message.reply_text("The channel has no messages.")
        return

    # Iterate over the messages and look for files
    for message in messages:
        if "document" in message:
            file = message["document"]
            file_id = file["file_id"]
            file_name = file["file_name"]

            # Download the file
            filepath = os.path.join('/home/vitor/Área de Trabalho/Excel Impressionador com VBA-Hashtag Treinamentos/21,10gb/93h 06minteste/', file_name)  # Replace with the desired save directory
            context.bot.get_file(file_id).download(custom_path=filepath)
            print("Download completed:", file_name)

# Configure the bot and handlers
updater = Updater(token='6245090703:AAGg1tUWWMfTTdKEMOaL7ZuhCa-Sl8zWXdg', use_context=True)
dispatcher = updater.dispatcher
dispatcher.add_handler(CommandHandler("downloadall", download_all))

# Start the bot
updater.start_polling()

import random
from os import system, name

# Class to represent a hangman game
class Hangman:

    def __init__(self, words):
        self.words = words
        self.word = random.choice(self.words)
        self.board = ["_"] * len(self.word)
        self.chances = 6
        self.wrong_letters = []

    def display_hangman(self):
        stages = [
            '''
          +---+
          |   |
          O   |
         /|\\ |
         / \\ |
              |
        =========
        ''',
            '''
          +---+
          |   |
          O   |
         /|\\ |
         /   |
              |
        =========
        ''',
            '''
          +---+
          |   |
          O   |
         /|\\ |
              |
              |
        =========
        ''',
            '''
          +---+
          |   |
          O   |
         /|   |
              |
              |
        =========
        ''',
            '''
          +---+
          |   |
          O   |
          |   |
              |
              |
        =========
        ''',
            '''
          +---+
          |   |
              |
              |
              |
              |
        =========
        ''',
            '''
          +---+
              |
              |
              |
              |
              |
        =========
        '''
        ]
        return stages[6 - self.chances]

    def check_guess(self, guess):
        if guess in self.word:
            for index, letter in enumerate(self.word):
                if guess == letter:
                    self.board[index] = guess
        else:
            self.chances -= 1
            self.wrong_letters.append(guess)

    def has_won(self):
        return "_" not in self.board

    def has_lost(self):
        return self.chances == 0

    def draw_hangman(self):
        system('cls' if name == 'nt' else 'clear')
        print(self.display_hangman())
        print(" ".join(self.board))
        print('\nRemaining chances:', self.chances)
        print("Wrong letters:", " ".join(self.wrong_letters))

    def play(self):
        while not self.has_won() and not self.has_lost():
            self.draw_hangman()
            guess = input("\nEnter a letter: ").lower()
            self.check_guess(guess)

        if self.has_won():
            print("\nCongratulations! You won the game! The word was:", self.word)
        else:
            print("\nYou lost. The word was:", self.word)

# Main block
if __name__ == '__main__':
    words = ['banana', 'avocado', 'grape', 'strawberry', 'orange']
    game = Hangman(words)
    game.play()
    print("Game developed by Vitor Campos at Data Science Academy Course.")

"""- Office Home & Student 2021: 6W6PY-GNMT3-V6Q9Q-9PXTC-Q86DQ
- Office Home & Business 2021: D6QFG-VBYP2-XQHM7-J97RH-VVRCK
- Office Professional 2021: NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP
"""

import random
import string

letters_digits = string.ascii_uppercase + string.digits

def generate_activation_key():
    key = '-'.join(''.join(random.choices(letters_digits, k=5)) for _ in range(5))
    return key

# Exemplo de uso
activation_key = generate_activation_key()
print(activation_key)

"""Código Tainá contagem candidatos co concurso CRFMG"""

!pip install PyPDF2
import PyPDF2

# Abre o arquivo PDF
pdf_file = open('CRFMG.pdf', 'rb')

# Cria um objeto PdfReader
pdf_reader = PyPDF2.PdfReader(pdf_file)

# Inicializa o contador de ocorrências da string "Farmacêutico Fiscal"
count = 0

# Loop através de todas as páginas do PDF
for page in pdf_reader.pages:

    # Obtém o texto da página atual
    page_text = page.extract_text()

    # Conta quantas vezes a string "Farmacêutico Fiscal" aparece na página atual
    count += page_text.count("Contador")

# Fecha o arquivo PDF
pdf_file.close()

# Imprime o número total de ocorrências da string "Farmacêutico Fiscal" no documento
print("Aparece", count, "vezes no documento CRFMG.")

"""CÓDIGO VITOR PARA GISÉLIA - ORDENAÇÃO DE TABELA EM DOCX"""

!pip install python-docx
import docx
from google.colab import files

# Faz o upload do arquivo docx
uploaded = files.upload()

# Carrega o arquivo docx
doc = docx.Document('LP.docx')

# Obtém o índice da coluna que deseja ordenar
coluna_nome = 'NOME'
tabela = doc.tables[0] # supondo que a tabela está na primeira página do documento
for i, celula in enumerate(tabela.rows[0].cells):
    if celula.text.strip() == coluna_nome:
        indice_coluna = i
        break

# Ordena a coluna em ordem alfabética crescente
dados_coluna = [celula.text.strip() for celula in tabela.columns[indice_coluna].cells[1:]]
dados_ordenados = sorted(dados_coluna)
dados_ordenados.insert(0, coluna_nome)

# Substitui a coluna original pela coluna ordenada
for i, celula in enumerate(tabela.rows[0].cells):
    if celula.text.strip() == coluna_nome:
        for j in range(1, len(tabela.rows)):
            tabela.rows[j].cells[i].text = dados_ordenados[j]

# Salva o arquivo ordenado em um novo arquivo docx
doc.save('arquivo_ordenado.docx')

# Faz o download do arquivo ordenado
files.download('arquivo_ordenado.docx')

"""Código para ordenar em ordem alfabética tabela em arquivo docx"""

!pip install python-docx pandas

import pandas as pd
import docx

# Abre o arquivo docx
doc = docx.Document('/content/LPsinternacionais.docx')

# Obtém a tabela desejada
tabela = doc.tables[0]

# Obtém os dados da tabela
dados = []
cabecalho = [celula.text.strip() for celula in tabela.rows[0].cells]
for linha in tabela.rows[1:]:
    linha_dados = [celula.text.strip() for celula in linha.cells]
    dados.append(linha_dados)

# Cria um dataframe a partir dos dados da tabela
df = pd.DataFrame(dados, columns=cabecalho)

# Ordena o dataframe pela coluna "Nome"
df = df.sort_values('NOME')

# Substitui os dados da tabela pelos dados ordenados do dataframe
for i, linha in enumerate(tabela.rows[1:]):
    for j, celula in enumerate(linha.cells):
        celula.text = df.iloc[i, j]

# Salva as alterações de volta no arquivo docx
doc.save('/content/exemplo_ordenado.docx')

!pip install python-docx pandas

import pandas as pd
import docx
from google.colab import files

# Mensagem para o usuário
print("Por favor, faça o upload do arquivo manualmente utilizando o botão 'Escolher arquivo' no canto esquerdo da célula do Colab.")

# Faz o upload do arquivo docx
uploaded = files.upload()

# Abre o arquivo docx
doc = docx.Document('/content/LP.docx')

# Obtém a tabela desejada
tabela = doc.tables[0]

# Obtém os dados da tabela
dados = []
cabecalho = [celula.text.strip() for celula in tabela.rows[0].cells]
for linha in tabela.rows[1:]:
    linha_dados = [celula.text.strip() for celula in linha.cells]
    dados.append(linha_dados)

# Cria um dataframe a partir dos dados da tabela
df = pd.DataFrame(dados, columns=cabecalho)

# Ordena o dataframe pela coluna "Nome"
df = df.sort_values('NOME')

# Substitui os dados da tabela pelos dados ordenados do dataframe
for i, linha in enumerate(tabela.rows[1:]):
    for j, celula in enumerate(linha.cells):
        celula.text = df.iloc[i, j]

# Salva as alterações de volta no arquivo docx
doc.save('/content/exemplo_ordenado.docx')

!pip install python-docx pandas

import pandas as pd
import docx
from google.colab import files

# Mensagem para o usuário
print("Por favor, faça o upload do arquivo manualmente utilizando o botão 'Escolher arquivo' no canto esquerdo da célula do Colab.")

# Faz o upload do arquivo docx
uploaded = files.upload()

# Obtém o nome do arquivo enviado
nome_arquivo = next(iter(uploaded))

# Abre o arquivo docx
doc = docx.Document(nome_arquivo)

# Obtém a tabela desejada
tabela = doc.tables[0]

# Obtém os dados da tabela
dados = []
cabecalho = [celula.text.strip() for celula in tabela.rows[0].cells]
for linha in tabela.rows[1:]:
    linha_dados = [celula.text.strip() for celula in linha.cells]
    dados.append(linha_dados)

# Cria um dataframe a partir dos dados da tabela
df = pd.DataFrame(dados, columns=cabecalho)

# Ordena o dataframe pela coluna "Nome"
df = df.sort_values('NOME')

# Substitui os dados da tabela pelos dados ordenados do dataframe
for i, linha in enumerate(tabela.rows[1:]):
    for j, celula in enumerate(linha.cells):
        celula.text = df.iloc[i, j]

# Salva as alterações de volta no arquivo docx
doc.save(nome_arquivo)

"""Data Science Academy - exercício 1 - ordenação de lista:"""

def bubble_sort(arr):
    n = len(arr)
    #para cada elemento i do array
    for i in range(n):
        #para cada elemento j do array:
        for j in range(0, n-i-1):
            #se o elemento i for maior que o elemento j
            if arr[j] > arr[j + 1]:
                #Troca os elementos i e j
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

lista = [ 45, 67, 89, 10, 1, 2, 5, 77, 25, 65, 33]

#bubble_sort(lista)

lista1 = lista.sort()

print(lista)

#Loop Aninhado

lista1 = [0,1,2,3,4]
lista2 = [1,2,3]

#Loop externo

for i in lista1:
    #loop interno
    for j in lista2:
        print('\n', i * j)
    print('----')

#Loop Aninhado
#O numero 47 aparece nas 2 listas?

lista1 = [10,16,24,39,47]
lista2 = [32,89,47,76,12]

#loop externo
for elemento_lista1 in lista1:
    #loop interno
    for elemento_lista2 in lista2:
        #condicional
        if elemento_lista1 == 47 and elemento_lista2 == 47:
            print("O número 47 foi encontrado nas duas listas!")

#Some os números pares da 1 lista com os números pares da 2 lista

lista1 = [10,16,24,39,47]
lista2 = [32,89,47,76,12]
soma = 0

#Loop externo:
for lista in [lista1, lista2]:
    #loop interno
    for num in lista:
        #Condicional
        if num % 2 == 0:
            soma += num
print(f"A soma dos números pares das duas listas é igual a {soma}.")

#Loop de listas em listas (na prática matrizes em python) para encontrar o maior número:
matriz = [[42, 23, 34], [100, 215, 114], [10.1, 98.7, 12.3]]
maior_numero = 0

#loop externo
for linha in matriz:
    #loop interno
    for num in linha:
        #Condicional1
        if num > maior_numero:
            maior_numero = num

print("Maior número: ", maior_numero)

#Listando as chaves de um dicionário:
dict = {'k1': 'Python', 'k2': 'R', 'K3': 'Scala'}
for item in dict:
    print(item)
#Imprimindo chave e valor do dicionário. Usando o ,-método items() para retornar os itens de um dicionário
for k,v in dict.items():
    print(k,v)

#Loop While
valor = 0
while valor < 10:
    print(valor)
    valor += 1

x = 0
while x < 10:
    print('O valor de x nesta iteração é: ', x)
    print('x ainda é menor que 10, somando 1 a x')
    x += 1
else:
    print('Loop concluído!')
print(x)

#Pass Break e Continue
valor = 0
while valor < 10:
    if valor == 4:
        break
    else:
        pass
    print(valor)
    valor += 1

#Desconsiderando a letra z ao imrimir:
for letra in 'Python é zzz incrível!':
    if letra == 'z':
        continue
    print(letra, end='')

"""WHILE E FOR JUNTOS DSA"""

primos = []

#Loop for para percorrer os numeros de 2 a 30

for num in range (2, 31):
    #variável de controle
    eh_primo = True
#Loop while para verificar se o numero é primo
    i = 2
    while i <= num // 2:
        if num % i == 0:
            eh_primo = False
            break
        i += 1
    #adicionando o número primo na lista
    if eh_primo:
        primos.append(num)

print(primos)

"""CONCEITO DE MÉTODOS EM LINGUAGEM PYTHON: tudo em Python é um objeto e cada objeto tem métodos e atributos. Atributos são propriedades, características do objeto. Métodos são funções em ações que podem ser executadas nos objetos."""

lista = []
dir(lista)

help(lista.copy)

"""FUNÇÕES EM PYTHON DSA"""

def primeirafunc():
    nome = 'Bob'
    print(f'Hello {nome}!')
primeirafunc()

def segundafunc(nome):
    print('Hello %s' % (nome))
segundafunc('aluno')

def imprimenumero():
    #loop
    for i in range(0, 5):
        print('Número ' + str(i))
imprimenumero()

def addnum(primeironum, segundonum):
    print('Primeiro número: ', primeironum)
    print('Segundo número: ', segundonum)
    print('Soma:', primeironum + segundonum)

addnum(8, 10)

#Funções com número variável de argumentos:
def printVarinfo(arg1, *vartuple):
    #imprimindo o valor do 1 argumento
    print('O parâmetro passado foi: ', arg1)
    #imprimindo o valor do segundo argumento
    for item in vartuple:
        print("O parâmetro passado foi: ", item)
    return;

printVarinfo('Chocolate', 'Morango')

"""ESCOPO DE VARIÁVEL EM PYTHON - LOCAL E GLOBAL"""

#Variável Global
var_global = 10 #esta variável é global

#função
def multiplicanum(num1, num2):
    var_global = num1 * num2 #esta é uma variável local
    print(var_global)
multiplicanum(3, 8)

"""FUNÇÕES BUILT-IN EM PYTHON - DSA:"""

print(abs(-56)) #extrai valor absoluto
print(int(2.7))
print(str(9))
print(bool(1))
print(float(8))
print(int('23'))
print(float('32.34'))
#ETC ETC ETC

"""CRIANDO FUNÇÕES USANDO OUTRAS FUNÇÕES - DSA"""

import math
def numprimo(num):
    if (num % 2) == 0 and num > 2:
        return 'Este não é um número primo!'
    for i in range(3, int(math.sqrt(num)) + 1, 2):
        if (num % i) == 0:
            return 'Este número não é primo'
    return 'Este número é primo!'
numprimo(5)

"""FAZENDO SPLIT DE DADOS EM PYTHON"""

def split_string_palavra(text):
    return text.split(" ")

texto = 'Esta função será bastante útil para separar grandes volumes de dados.'

split_string_palavra(texto)

display(split_string_palavra(texto))

#Podemos atribuir o output de uma função para uma variável:
token = split_string_palavra(texto)
print(token)

#Fazendo split dos dados:
def split_string_palavra(text):
    texto = text.upper()
    for letra in texto:
        print(letra)
split_string_palavra(texto)

"""EXPRESSÃO LAMBDA - DSA"""

def potencia(num):
    resultado = num ** 2
    return resultado
#simplificando:
def potencia(num):
    return num ** 2
#Lambda
potencia = lambda num: num ** 2
print(potencia(5))
print(potencia(4))

#Lembre: operadores de comparação retornam boolean
par = lambda x: x%2 == 0
par(4)

first = lambda s: s[0]
print(first('Python'))
reverso = lambda s: s[::-1]
print(reverso('Python'))

addnum = lambda x,y : x+y
addnum(2,3)

"""LIST COMPREHENSION E DICT COMPREHENSION EM PYTON (expressão for item in iterable if condição == True)"""

[x for x in range(10)]
lista_numeros = [x for x in range(10)]
print(lista_numeros)

lista_numeros = [x for x in range(10) if x < 5]
print(lista_numeros)

lista_de_frutas = ['banana', 'abacate', 'melancia', 'cereja', 'manga']
nova_lista = []
for x in lista_de_frutas:
    if 'n' in x:
        nova_lista.append(x)
print(nova_lista)
print('-' * 150)
#Mesmo resultado com List Comprehension:
nova_lista = [x for x in lista_de_frutas if 'n' in x]
print(nova_lista)

"""DICT COMPRHENSION"""

dict_alunos = {'Bob': 68, 'Michel': 84, 'Tico': 57, 'Ana': 93}

dict_alunos_status = {k:v for (k, v) in dict_alunos.items()}
print(dict_alunos_status)

dict_alunos = {'Bob': 68, 'Michel': 84, 'Tico': 57, 'Ana': 93}

dict_alunos_status = {k:('Aprovado!' if v > 70 else 'Reprovado!') for (k,v) in dict_alunos.items()}
print(dict_alunos_status)

import platform

print('Versão da linguagem Python usada: ', platform.python_version())

"""DATA SCIENCE ACADEMY - MANIPULAÇÃO DE ARQUIVOS EM PYTHON - JSON - CSC - TXT"""

#Abrindo arquivo para leitura:
arq1 = open("/arquivo1.txt", 'r')
print(arq1.read())
print(arq1.tell()) # conta o número de caracteres do arquivo

arql = open("/arquivo1.txt", 'r')
print(arq1.seek(0,0)) #volta para o início do texto
print(arq1.read(23)) #lê apenas os 23 primeiros caracteres

arq2 = open("/arquivo2.txt", 'w') #Cuidado que o modo write sobreescreve o arquivo
arq2.write("Aprendendo a programar em Python.")
arq2.close()

arq2 = open("/arquivo2.txt", 'r')
print(arq2.read())

arq2 = open("/arquivo2.txt", 'a') # a = append
arq2.write(" E a metodologia da Data Science Academy facilita o aprendizado.")
arq2 = open("/arquivo2.txt", 'r')
print(arq2.read())

f = open("salarios.csv", 'r')
data = f.read()
rows = data.split('\n')
full_data = []
for row in rows:
    split_row = row.split(',')
    full_data.append(split_row)
count = 0
for row in full_data:
    count += 1
print(count)

f = open("salarios.csv", 'r')
data = f.read()
rows = data.split('\n')
full_data = []
for row in rows:
    split_row = row.split(',')
    full_data.append(split_row)
    first_row = full_data[0]
count = 0

for column in first_row:
    count += 1
print(count)

#Outra solução:
for column in full_data[0]:
    count += 1
print(count)

"""DSA - GRAVANDO ARQUIVO PELO JUPYTER NOTEBOOK"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile sample_data/arquivo3.txt
# Este arquivo foi gerado pelo Jupyter Notebook.
# Podemos gerar quantas linhas quisermos e o Jupyter grava no arquivo final.

arq3 = open("sample_data/arquivo3.txt", 'r')
print(arq3.read())

arq3.seek(0)
arq3.readlines() #permite ler linha à linha.

#Com isso, consegue-se fazer loop no arquivo extraindo linha à linha do mesmo
for line in open("sample_data/arquivo3.txt"):
    print(line)

"""DSA - BREVE INTRO AO PANDAS"""

import pandas as pd
pd.__version__

arquivo = 'salarios.csv'
df = pd.read_csv(arquivo)
df.head()

#Filtrando pelo nome da coluna:
df['Position Title'].value_counts() #se tiver espaço entre as strings, usa-se áspas simples ''.

"""DSA - MANIPULANDO ARQUIVOS TXT EM PYTHON COM PACOTE OS"""

from platform import python_version
print(python_version())

texto = 'Cientista de dado pode ser uma excelente escolha de carreira.\n'
texto = texto + 'Esses profissionais precisam saber programar em Python.\n'
texto += 'E, claro, devem ser profissionais em data science.'
print(texto)

import os
#criando um arquivo
arquivo = open(os.path.join("sample_data/cientista.txt"), 'w')
#gravando os dados no arquivo
for palavra in texto.split():
    arquivo.write(palavra + ' ')
arquivo.close()

#Lendo o arquivo
arquivo = open("sample_data/cientista.txt", 'r')
conteudo = arquivo.read()
arquivo.close()
print(conteudo)

"""DSA - Manipulando Arquivos TXT em Python com a Expressão WITH - o método close é executado automaticamente"""

#Lendo o arquivo
with open("cientista.txt", 'r') as arquivo:
    conteudo = arquivo.read()
print(len(conteudo))
print(conteudo)

with open("cientista.txt", 'w') as arquivo:
    arquivo.write(texto[:18])
    arquivo.write('\n')
    arquivo.write(texto[19:39])

#lendo o arquivo
arquivo = open("cientista.txt", 'r')
conteudo = arquivo.read()
arquivo.close()
print(conteudo)

"""DSA - MANIPULANDO CSV COM PACOTE CSV(COMMA SEPARATED VALUES) - é um formato de arquivo que armazena dados tabulares em formato de texto plano. É amplamente utilizado para importar ou exportar dados em diferentes aplicações, como planilhas e banco de dados. É uma opção simples e universal para compartilhar dados, pois pode ser aberto e editado por muitos aplicativos diferentes, incluindo programas de planilha e editores de texto."""

#Importando modulo csv - neste caso funciona no anaconda
import csv
with open('arquivos/numeros.csv', 'w') as arquivo:
    #cria o objeto de gravação
    writer = csv.writer(arquivo)
    #grava no arquivo linha a linha
    writer.writerow(('Nota1', 'Nota2', 'Nota3'))
    writer.writerow((63, 87, 92 ))
    writer.writerow((61, 79, 76))
    writer.writerow((72, 64, 91))

#Importando modulo csv - adaptado para o colab
import csv

with open('/content/numeros.csv', 'w') as arquivo:
    #cria o objeto de gravação
    writer = csv.writer(arquivo)
    #grava no arquivo linha a linha
    writer.writerow(('Nota1', 'Nota2', 'Nota3'))
    writer.writerow((63, 87, 92))
    writer.writerow((61, 79, 76))
    writer.writerow((72, 64, 91))

#Leitura de arquivo csv
#encondin="uft8"
with open('/content/numeros.csv', 'r', encoding='utf8', newline = '\r\n') as arquivo:
    #cria o objeto de leitura
    leitor = csv.reader(arquivo)
    #loop que vai percorrer o objeto e imprimir cada linha dele
    for x in leitor:
        print(x)

#Gerando uma lista com dados do arquivo csv
with open('/content/numeros.csv', 'r') as arquivo:
    leitor = csv.reader(arquivo)
    dados = list(leitor)
print(dados)

#imprimir info a partir da 2 linha
for linha in dados[1:]:
    print(linha)

"""DSA - MANIPULANDO ARQUIVOS JSON EM PYTHON COM PACOTE JSON(Java Script Object Notation) - é um formato de dados de texto simples e leve que é utilizado para transmitir informações em aplicações web. É baseado em uma estrutura de objetos JavaScript e usa pares de "chave-valor" para representar dados. É facilmente escrito e lido por máquinas e é amplamente utilizado como formato de intercâmbio de dados em aplicações web modernas."""

#Criando um dicionário
dict_guido = {
    'Nome:': 'Guido Van Rossum',
    'Linguagem:': 'Python',
    'Similar:': ['c', 'Modula-3', 'lisp'],
    'Users:': 1000000
}

for k,v in dict_guido.items():
    print(k, v)

#Importando o pacote Json
import json

#Convertendo o dicionário para um objeto jason
json.dumps(dict_guido)

#Criando um arquivo Json
with open('/content/dados.json', 'w') as arquivo:
    arquivo.write(json.dumps(dict_guido))

#Leitura de arquivo json
with open('/content/dados.json', 'r') as arquivo:
    texto = arquivo.read()
    dados = json.loads(texto)

dados

print(dados['Nome:'])

"""EXTRAÇÃO DE ARQUIVO JSON DA WEB"""

#Imprimindo um arquivo json copiado da internet
import json
from urllib.request import urlopen
response = urlopen("http://vimeo.com/api/v2/video/57733101.json").read().decode('utf8')
dados = json.loads(response)[0]

dados

#Como obtemos chave e valor, posso usar a chave para extrair o valor
print('Título: ', dados['title'])
print('URL: ', dados['url'])
print('Duração: ', dados['duration'])
print('Número de visualizações: ', dados['stats_number_of_plays'])

#Nome dos arquivos
arquivo_fonte = 'arquivos_dados.json'
arquivo_destino = 'arquivos_dados.txt'

#Nome dos aruivos, porém adaptado para o colab
arquivo_fonte = '/content/arquivos_dados.json'
arquivo_destino = '/content/arquivos_dados.txt'

#Método 1
with open(arquivo_fonte, 'r') as infile:
    text = infile.read()
    with open(arquivo_destino, 'w') as outfile:
        outfile.write(text)

#Método 2
open(arquivo_destino, 'w').write(open(arquivo_fonte, 'r').read())

#Leitura de um arquivo txt
with open('/content/arquivos_dados.txt', 'r') as arquivo:
    texto=arquivo.read()
    dados = json.loads(texto)

print(dados)

"""DSA - PACOTES E MÓDULOS
Em Python, um módulo é um arquivo (script) que contém código Python e pode ser importado em outros arquivos Python. Ele é usado para compartilhar ações, classes e variáveis entre arquivos. Já um pacote é uma coleção de módulos organizados em uma estrutura de diretórios. Ele permite a divisão de um aplicativo em múltiplos módulos, facilitando a manutenção e desenvolvimento. O repositório de pacotes da linguagem Python se encontra no Pypi: https://pypi.org/
"""

#Importando um pacote
import numpy

#Verificando todos os métodos e atributos disponíveis em um pacote
dir(numpy)

#usando um dos métodos do numpy
numpy.sqrt(25)

print(round(numpy.sqrt(30)))

#Importando apenas um dos métodos
from numpy import sqrt
#Usando o método
sqrt(9)

#Para atualizar um pacote -U(update)
!pip install -U pandas

#Para retirar o pacote
!pip uninstall pandas

"""ESTUDO PYTHON ACADEMY - MANIPULANDO ARQUIVOS

para arquivos de texto: (r - read r+), (w write w+) , (a append a+).
para arquivos binários: (rb - rb+), (wb, wb+), (ab, ab+).
"""

#Estrutura
#open("/user/home/dados.txt", 'r') - é preciso passar à uma variável
#ex: arquivo = open("/user/home/dados.txt", 'r')
#arquivo2 = open("/user/home/dados.txt", 'r+')

#o (./) significa que estou utilizando o diretorio do projeto e o arquivo precisa estar nele.
#Neste sistema não podemos fechar o arquivo, pois ele esta no contexto da tabulação with open.

with open("./cadastro.csv", "r") as arquivo_entrada:
    linhas = arquivo_entrada.readlines() #retorna todas a linhas sem precisar iterar sobre o arquivo

    pass


#estudo_arquivo_csv

help(sqrt)

"""DSA - FUNÇÃO MAP - A FUNÇÃO MAP É UMA FUNÇÃO QUE APLICA UMA DETERMINADA FUNÇÃO A CADA ELEMENTO DE UMA ESTRUTURA DE DADOS ITERÁVEL(COMO UMA LISTA, TULPA OU OUTRO OBJETO ITERÁVEL). A FUNÇÃO MAP RETORNA UM OBJETO QUE PODE SER CONVERTIDO EM OUTRA ESTRUTURA DE DADOS, COMO UMA LISTA, SE NECESSÁRIO."""

# Função Python que retorna um número ao quadrado
def potencia(x):
    return x ** 2
numeros = [1, 2, 3, 4, 5]
numeros_ao_quadrado = list(map(potencia, numeros)) # a função map vai aplicar a função potencia na lista numeros (em cada número da lista)
print(numeros_ao_quadrado)

#Criando duas funções

#Função 1 - Recebe uma temperatura como parâmetro e retorna a temperatura Fahrenheit
def fahrenheit(T):
    return ((float(9)/5)* T + 32)
#Função 2 - Recebe uma temperatura como parâmetro e retorna a temperatura em Celsius
def celsius(T):
    return (float((5)/9)*(T-32))
#Criando uma lista
temperaturas = [0, 22.5, 40, 100]
#Aplicando a função a cada elemento da lista de temperaturas.
#Em Python 3, a função map() retorna um iterator - objeto pelo qual você pode navegar
map(fahrenheit, temperaturas)

#Função map() retornando a lista de temperaturas convertidas em Fahrenheit
list(map(fahrenheit, temperaturas))

#Usando um loop for para imprimir o resultado da função map()
for temp in map(fahrenheit, temperaturas):
    print(temp)

list(map(celsius, temperaturas))

#Usando expressão lambda
map(lambda x: (5.0/9) * (x-32), temperaturas)

list(map(lambda x: (5.0/9) * (x-32), temperaturas))

#Somando os elementos de duas listas
a = [1, 2, 3, 4]
b = [5, 6 ,7, 8]

list(map(lambda x, y: x + y, a, b))

#Somando os elementos de três listas
#Somando os elementos de duas listas
a = [1, 2, 3, 4]
b = [5, 6 ,7, 8]
c = [9, 10, 11, 12]

list(map(lambda x, y, z: x + y + z, a, b, c))

"""FUNÇÃO REDUCE - visa reduzir uma lista de elementos a um único valor, podendo ser a soma deles, o maior valor, o menor, etc."""

#Importando a função reduce do módulo functools
from functools import reduce

#criando uma lista
lista = [47, 11, 42, 13]
lista
#função
def soma(a, b):
    x = a + b
    return x
#Usando reduce com uma função e uma lista. A função vai retornar o valor máximo
reduce(soma,lista)

#criando uma lista
first = [47, 11, 42, 13]

#Usando a função reduce() com lambda
max_find2 = lambda a, b: a if (a > b) else b
type(max_find2)

#Reduzindo a lista até o valor máximo, através da função criada com a expressão lambda
reduce(max_find2, first)

"""FUNÇÃO FILTER - FILTRA A UM CONJ DE DADO (OBJETO ITERÁVEL)"""

#Criando a função
def verificarPar(num):
    if num % 2 == 0:
        return 'Número par.'
    else:
        return 'Número ímpar!'
#Chamando a função e passando um número como parâmetro. Retornará
#False se for ímpar e True se for par
verificarPar(35)

verificarPar(10)

lista = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
lista

# A função filter() retorna um iterador
filter(verificarPar, lista)

list(filter(verificarPar, lista))

list(filter(lambda x: x%2 == 0, lista))

list(filter(lambda num: num > 8, lista))

"""FUNÇÃO ZIP - a função zip() agrupa elementos de múltiplas estruturas de dados iteráveis (como tuplas, listas ou outros objetos iteráveis) junto em pares. A funçaõ zip() retorna um objeto zip, que pode ser convertido em outra estrutura de dados, como uma lista ou dicionário, se necessário."""

#Criando duas listas
x = [1,2,3]
y = [4,5,6]

#Unindo as listas. Em Python 3 retorna um iterador
zip(x,y)

#Perceba que zip retorna tuplas. Neste caso, uma lista de tuplas
list(zip(x,y))

#Atenção quando as sequências tiverem número diferente de elementos
list(zip('ABCD', 'XY'))

#Criando duas listas
a = [1,2,3]
b = [4,5,6,7,8]
list(zip(a,b))

#Criando 2 dicionários
d1 = {'a': 1, 'b': 2}
d2 = {'c': 4, 'd': 5}

#zip vai unir as chaves
list(zip(d1, d2))

#zip pode unir os valores(itens)
list(zip(d1, d2.values()))

#zip pode unir os valores(itens)
list(zip(d1.values(), d2.values()))

#Criando uma função para trocar valores entre 2 dicionarios
def trocaValores(d1, d2):
    dictTemp = {}
    for d1key, d2val in zip(d1, d2.values()):
        dictTemp[d1key] = d2val
    return dictTemp
trocaValores(d1, d2)

"""FUNÇÃO ENUMERATE - enumerate() permite iterar sobre uma estrutura de dados(como uma lista, ou tupla ou outro objeto iterável). A função enumerate() retorna um objeto enumerado, que pode ser usado em loops para percorrer a estrutura de dados e acessar o contador e o valor de cada elemento."""

# criando uma lista
seq = ['a', 'b', 'c']
enumerate(seq)
list(enumerate(seq))

#Imrimindo os valores de uma lista com a função  enumerate() e seus respectivos índices
for indice, valor in enumerate(seq):
    print(indice, valor)

#imprimindo os valores de uma lista com a função enumerate() e seus respectivos índices
for indice, valor in enumerate(seq):
    if indice >= 2:
        break
    else:
        print(valor)

lista = ['Marketing', 'Tecnologia', 'Business']
for i, item in enumerate(lista):
    print(i, item)

for i, item in enumerate('Data Science Academy'):
    print(i, item)

for i, item in enumerate(range(10)):
    print(i, item)

"""DSA - TRATAMENTO DE ERROS E EXCEÇÕES - sempre leia as mensagens de erro. Erros fazem parte do processo de aprendizagem e vão acompanha-lo durante sua jornada em programação, em qualquer linguagem."""

#leia o erro
print('Helo)

#Erro (leia a mensagem de erro)
8 + 's'

#criando uma função
def numDiv(num1, num2):
    resultado = num1 / num2
    print(resultado)
#ececução que gera erro:
numDiv(4, 0)

#execução sem erro:
numDiv(4, 2)

"""TRY, EXCEPT, FINALLY"""

# 8 + 'S' utilizando try e except
try:
    8 + 's'
except TypeError:
    print('Erro. Não se faz operações entre tipo número e string')

#Utiliando try, except e else
try:
    with open('/content/testandoerros.txt', 'w') as f:  # Corrigido para o modo de escrita ('w')
        f.write('Gravando no arquivo')
except IOError:
    print('Erro: arquivo não pode ser salvo.')
else:
    print("Conteúdo gravado com sucesso!")

#Utilizando try, except e else - dando erro
try:
    f = open('/content/testandoerro', 'r')
except IOError:
    print("Erro: arquivo não encontrado ou não pode ser salvo.")
else:
    print("Conteúdo gravado com sucesso!")
    f.close()

#Utilizando try, except, else e finally
try:
    with open('/content/testandoerros.txt', 'w') as f:  # Corrigido para o modo de escrita ('w')
        f.write('Gravando no arquivo')
except IOError:
    print("Erro: arquivo não encontrado ou não pode ser salvo.")
else:
    print("Conteúdo gravado com sucesso!")
finally:
    print("Comandos no bloco finally são sempre exectados!")

def askint():
    try:
        val = int((input('Digite um número: ')))
    except:
        print("Você não digitou um número!")
    finally:
        print("Obrigado!")
askint()

def askint():
    while True:  # Add a while loop to allow for multiple attempts
        try:
            val = int(input("Digite um número: "))
        except:
            print("Você não digitou um número válido!")  # Update error message
            continue
        else:
            print("Obrigado por digitar um número!")
            break
        finally:
            print("Obrigado!")
    print(val)
askint()

"""TRABALHANDO COM EXPRESSÕES REGULARES E CHATGPT - São uma sequência de caracteres que definem uma busca padrão em strings. Em Python, as Expressões Regulares são suportadas pelo pacote re. Ele fornece uma série de funções para pesquisar e substituir padrões em strings. Algumas das tarefas mais comuns que podem ser realizadas com Expressões Regulares incluem verificar se uma string corresponde a um determinado padrão, extrair informações de uma string com base em um padrão específico e substituir trechos de uma string com base em um padrão. Por exemplo, você pode usar uma expressão regular para verificar se uma string representa um endereço de e-mail válido, ou para encontrar todas as ocorrências de um padrão em uma string. Traremos agora uma série de exemplos para você. Bons estudos."""

import re
texto = "Meu email é exemplo@gmail.com.br e você pode me contatar em outro_email@gmail.com"
#Expressão regular para contar quantas vezes o caracter arroba aparece no texto.
resultado = len(re.findall("@", texto))
print("O caractere '@' apareceu", resultado, "vezes no texto.")

#Expressão regular para extrair a palavra que aparece após a palavra "você" em um texto.
resultado = re.findall(r'você (\w+)', texto)
print("A palavra após 'você' é:", resultado[0])

"""Nota: o r antes da string que representa a expressão regular em Python é usado para indicar que a string é uma string literal raw. Isso significa que as barras invertidas () não são interpretadas como caracteres de escape, mas são incluídas na expressão regular como parte do padrão."""

#Expressão regular para extrair endereços de e-mail de uma string
emails = re.findall(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b', texto)
print(emails)

text = "O aluno estava incrivelmente perdido, mas encontrou a DSA e rapidamente começou a aprender."

import re

text = "O aluno estava incrivelmente perdido, mas encontrou a DSA e rapidamente começou a aprender."

# Expressão regular para extrair advérbios
# Encontra os advérbios na frase
for m in re.finditer(r"\w+mente\b", text):
    print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0)))

"""REGEX COM CHATGPT"""

#Variável do tipo string:
#MÚSICA TEMPO PERDIDO:
musica = '''
Todos os dias quando acordo
Não tenho mais
O tempo que passou
Mas tenho muito tempo
Temos todo o tempo do mundo
Todos os dias
Antes de dormir
Lembro e esqueço
Como foi o dia
Sempre em frente
Não temos tempo a perder
Nosso suor sagrado
É bem mais belo
Que esse sangue amargo
E tão sério
E selvagem! Selvagem!
Selvagem!
Veja o sol
Dessa manhã tão cinza
A tempestade que chega
É da cor dos teus olhos
Castanhos
Então me abraça forte
E diz mais uma vez
Que já estamos
Distantes de tudo
Temos nosso próprio tempo
Temos nosso próprio tempo
Temos nosso próprio tempo
Não tenho medo do escuro
Mas deixe as luzes
Acesas agora
O que foi escondido
É o que se escondeu
E o que foi prometido
Ninguém prometeu
Nem foi tempo perdido
Somos tão jovens
Tão jovens! Tão jovens!
'''

print(musica)

#1 - Regex para contar quantas vezes o caracter "a" aparece em todo o texto da música.

# Expressão regular para contar o caractere "a"
regex = r"a"

# Encontra todas as ocorrências do caractere "a" no texto da música
ocorrencias = re.findall(regex, musica)

# Conta o número de ocorrências
total_ocorrencias = len(ocorrencias)

# Imprime o resultado
print("O caractere 'a' aparece", total_ocorrencias, "vezes no texto da música.")

#2 - Crie um Regex em Python contar quantas vezes a palavra tempo aparece na música.

# Expressão regular para contar a palavra "tempo"
regex = r"\btempo\b"

# Encontra todas as ocorrências da palavra "tempo" no texto da música
ocorrencias = re.findall(regex, musica, re.IGNORECASE)

# Conta o número de ocorrências
total_ocorrencias = len(ocorrencias)

# Imprime o resultado
print("A palavra 'tempo' aparece", total_ocorrencias, "vezes no texto da música.")

#3 - Crie um Regex para extrair as palavras seguidas por exclamação.
# Contar o número de palavras seguidas por exclamação
palavras_exclamacao = re.findall(r'\b\w+!\B', musica)
num_palavras_exclamacao = len(palavras_exclamacao)

# Imprimir o resultado
print('Número de palavras seguidas por exclamação:', num_palavras_exclamacao)

#4 - Crie um Regex que extrai qualquer palavra cujo antecessor seja a palavra "esse" e o sucessor seja a palavra "amargo" em um texto
# Expressão regular
regex = r'\besse\s\w+\samargo\b'

# Encontrar palavras que têm "esse" como antecessor e "amargo" como sucessor
palavras = re.findall(regex, musica)

# Imprimir palavras encontradas
print(palavras)

# 5 Crie um Regex que retorne as palavras com acento, mas somente os caracteres na palavra que são anteriores ao caracter com acento
# Expressão regular
regex = r"\b(\w*[áéíóúâêôàèïüãõç]+\w*)\w*"

#Encontrar palavras com acento e caracteres anteriores
palavras_acento = re.findall(regex, musica)

#Imprimir palavras encontradas
print(palavras_acento)

#Solução DSA
resultado5 = re.findall(r"\b([\wÀ-ÿ]+[áéíóúãõç])", musica)
print("As palavras acentuadas são:", resultado5)

"""DSA - PROJETO 1 - DESENVOLVIMENTO DE GAME EM LINGUAGEM PYTHON"""

import random
from os import system, name

# Função para limpar a tela a cada execução
# Windows
def limpa_tela():
    if name == 'nt':  # 'nt' é o nome interno dado ao sistema Windows e não importa qual versão dele
        system('cls')
    # Mac ou Linux
    else:
        system('clear')

# Função que desenha a forca na tela:
def display_hangman(chances):
    stages = [
        '''
          +---+
          |   |
          O   |
         /|\  |
         / \  |
              |
        =========
        ''',
        '''
          +---+
          |   |
          O   |
         /|\  |
         /    |
              |
        =========
        ''',
        '''
          +---+
          |   |
          O   |
         /|\  |
              |
              |
        =========
        ''',
        '''
          +---+
          |   |
          O   |
         /|   |
              |
              |
        =========
        ''',
        '''
          +---+
          |   |
          O   |
          |   |
              |
              |
        =========
        ''',
        '''
          +---+
          |   |
          O   |
              |
              |
              |
        =========
        '''
    ]
    return stages[chances]

# Função principal do jogo
def game():
    limpa_tela()
    print('\nBem-vindo(a) ao jogo da forca!')
    print("Adivinhe a palavra abaixo:\n")

    # Lista de palavras para o jogo
    palavras = ['banana', 'abacate', 'uva', 'morango', 'laranja']
    # Escolhe randomicamente uma palavra
    palavra = random.choice(palavras)

    # Lista de letras de palavras
    lista_letras_palavras= [letra for letra in palavra]

    #Cria o tabuleiro com o caracter "_" multiplicando pelo comprimento da palavra
    tabuleiro = ["_"] * len(palavra)

    # Número de chances
    chances = 6

    # Lista para as letras erradas
    letras_erradas = []

    # Loop enquanto o número de chances for maior que zero
    while chances > 0:
        # Print
        print(" ".join(tabuleiro))
        print('\nChances restantes:', chances)
        print("Letras erradas:", " ".join(letras_erradas))

        # Tentativa
        tentativa = input("\nDigite uma letra: ").lower()

        # Condicional
        if tentativa in palavra:
            index = 0
            for letra in palavra:
                if tentativa == letra:
                    tabuleiro[index] = letra
                index += 1
        else:
            chances -= 1
            letras_erradas.append(tentativa)

        # Condicional
        if "_" not in tabuleiro:
            print("\nVocê venceu o jogo! A palavra era:", palavra)
            break

    # Condicional
    if "_" in tabuleiro:
        print("\nVocê perdeu. A palavra era:", palavra)

# Bloco main
if __name__ == '__main__':
    game()
    print("Jogo desenvolvido por Vitor Campos perante o Curso da Data Science Academy.")

import random
from os import system, name

# Função para limpar a tela a cada execução
# Windows
def limpa_tela():
    if name == 'nt':  # 'nt' é o nome interno dado ao sistema Windows e não importa qual versão dele
        system('cls')
    # Mac ou Linux
    else:
        system('clear')

# Função que desenha a forca na tela:
def display_hangman(chances):
    stages = [
        '''
          +---+
          |   |
          O   |
         /|\  |
         / \  |
              |
        =========
        ''',
        '''
          +---+
          |   |
          O   |
         /|\  |
         /    |
              |
        =========
        ''',
        '''
          +---+
          |   |
          O   |
         /|\  |
              |
              |
        =========
        ''',
        '''
          +---+
          |   |
          O   |
         /|   |
              |
              |
        =========
        ''',
        '''
          +---+
          |   |
          O   |
          |   |
              |
              |
        =========
        ''',
        '''
          +---+
          |   |
          O   |
              |
              |
              |
        =========
        ''',
        '''
          +---+
          |   |
              |
              |
              |
              |
        =========
        '''
    ]
    return stages[chances]

# Função principal do jogo
def game():
    limpa_tela()
    print('\nBem-vindo(a) ao jogo da forca!')
    print("Adivinhe a palavra abaixo:\n")

    # Lista de palavras para o jogo
    palavras = ['banana', 'abacate', 'uva', 'morango', 'laranja']
    # Escolhe randomicamente uma palavra
    palavra = random.choice(palavras)

    # Lista de letras de palavras
    lista_letras_palavras= [letra for letra in palavra]

    #Cria o tabuleiro com o caracter "_" multiplicando pelo comprimento da palavra
    tabuleiro = ["_"] * len(palavra)

    # Número de chances
    chances = 6

    # Lista para as letras erradas
    letras_erradas = []

    # Loop enquanto o número de chances for maior que zero
    while chances > 0:
        limpa_tela()
        print(display_hangman(chances))
        print(" ".join(tabuleiro))
        print('\nChances restantes:', chances)
        print("Letras erradas:", " ".join(letras_erradas))

        # Tentativa
        tentativa = input("\nDigite uma letra: ").lower()

        # Condicional
        if tentativa in palavra:
            index = 0
            for letra in palavra:
                if tentativa == letra:
                    tabuleiro[index] = letra
                index += 1
        else:
            chances -= 1
            letras_erradas.append(tentativa)

        # Condicional
        if "_" not in tabuleiro:
            print("\nVocê venceu o jogo! A palavra era:", palavra)
            break

    # Condicional
    if "_" in tabuleiro:
        print("\nVocê perdeu. A palavra era:", palavra)

# Bloco main
if __name__ == '__main__':
    game()
    print("Jogo desenvolvido por Vitor Campos perante o Curso da Data Science Academy.")

"""DATA SCIENCE ACADEMY - PROGRAMAÇÃO ORIENTADA A OBJETO

Programação Orientada a Objetos (POO) é um paradigma de programação que se baseia no  conceito  de  "objetos",  que  são  entidades  que  possuem  características  (atributos)  e comportamentos (métodos). Em POO, o foco está na criação de objetos que interagem entre si para realizartarefas. A POO tem como princípio a encapsulação, que é a capacidade de um objeto de ocultar seus detalhes internos e expor apenas o necessário para interagir com outros objetos. Além disso, a POO também se baseia em herança e polimorfismo, que permitem a reutilização de código e a criação de hierarquias de classes que representam conceitos e objetos mais abstratos. Dentre as linguagens de programação mais populares que utilizam POO, podemos citar Java,  Python,  C++,  C#,  Ruby,  entre  outras.  A  POO  é  uma  abordagem  muito  utilizada  no desenvolvimento de software moderno, permitindo a criação de sistemas complexos e escaláveis de forma organizada e eficiente.POO  também é  o  paradigma de  programação comummente usado  para  construir algoritmos de MachineLearning.

Classes - Em POO uma classe é uma estrutura que define um objeto, especificando os atributos e comportamentos que o objeto deve ter. Uma classe é uma espécie de modelo que define as características e ações que um objeto deve possuir. As classes são usadas para criar objetos, que são instancias da classe. Cada objeto criado a partir da mesma classe terá os mesmos atributos e comportamentos. Para criar uma classe em Python, utiliza-se a palavra reservada "class". O nome da classe segue a mesma convenção de nomes para a criação de funções e variáveis em Python, mas normalmente se usa a primeira letra maiúscula em cada palavra do nome da classe.
"""

#Criando uma classe chamada livro
#este método vai inicializar cada objeto criado a partir desta classe
#o nome deste método é __init__
#(self) é uma referência a cada atributo da pŕopria classe ( e não de uma classe mãe, p. ex).

class Livro():

    def __init__(self):
        #Atributos são propriedades
        self.titulo = "Sapiens - Uma Breve História da Humanidade"
        self.isbn = 9988888
        print("Construtor chamado para criar um objeto desta classe.")

    #Métodos são funções que executam ações nos objetos da classe
    def imprime(self):
        print("Foi criado o livro %s com o ISBN %d" %(self.titulo, self.isbn))

"""Em Python a palavra reservada self é uma referência ao objeto atual da classe. Quando um objeto é criado a partir de uma classe, self é utilizado para se referir a este objeto específico."""

#Criando uma instância da classe livro
livro1 = Livro()

#O objeto livro1 é do tipo livro
type(livro1)

livro1.imprime()

print(dir(livro1))

#Melhorando a classe
#criando a classe Livro com parâmetros no método construtor
class Livro():
    def __init__(self, titulo, isbn):
        self.titulo = titulo
        self.isbn = isbn
        print("Construtor chamado para criar esta classe!")

    def imprime(self, titulo, isbn):
        print("Este livro é: %s, isbn %d." %(titulo, isbn))

#Criando o objeto livro 2 que é uma instância da classe Livro
livro2 = Livro("O poder do hábito", 7886611)

livro2.titulo

#método do objeto livro2
livro2.imprime("O poder do hábito", 7886611)

#Criando a classe cachorro
class Algoritmo():

    def __init__(self, tipo_algo):
        self.tipo = tipo_algo
        print("Construtor chamado para criar um objeto desta classe.")

#Criando um objeto a partir da classe
algo1 = Algoritmo(tipo_algo = "Random_forest")

#Criando um objeto a partir da classe
algo2 = Algoritmo(tipo_algo = "Deep Learning")

algo1.tipo

algo2.tipo

#Criando uma classe

class Funcionarios():

    def __init__(self, nome, salario, cargo):
        self.nome = nome
        self.salario = salario
        self.cargo = cargo

    def listFunc(self):
        #imprimi na tela concatenando string com valor de cada atributo
        print("Funcionário(a) " + self.nome + " tem salário de R$" + str(self.salario) + " e o cargo é " + self.cargo)

#criando um objeto chamado Func1 a partir da classe Funcionarios
Func1 = Funcionarios("Mary", 2000, "cientista de dados")

Func1.listFunc()

"""Manipulando atributos

"""

#conferindo se tem atributo:
hasattr(Func1, "nome")

hasattr(Func1, "salario")

setattr(Func1, "salario", 4500)

hasattr(Func1, "salario")

getattr(Func1, "salario")

delattr(Func1, "salario")

hasattr(Func1, "salario")

"""MÉTODOS - Em Python, os métodos de classe são funções definidas dentro de uma classe que realizam operações específicas em objetos criados a partir dessa classe. Os métodos de classe são usados para implementar o comportamento dos objetos que pertencem a essa classe. Assim como as funções em Python, os métodos de classe podem receber argumentos e retornar valores. No entanto, diferentemente das funções normais, os métodos de classe sempre incluem o parâmetro self como o primeiro argumento, que é usado para se referir ao objeto atual da classe. O método init é um método especial que é chamado quando um objeto é criado a partir da classe. Este método é usado para inicializar os atributos do objeto. Outros métodos podem ser definidos para executar tarefas específicas em um objeto, como calcular valores, realizar operações de entrada e saída, ou alterar o estado do objeto.

"""

#Criando uma classe chamada Circulo

class Circulo():

    #O valor de pi é constante

    pi = 3.14

    def __init__(self, raio = 5):
        self.raio = raio

    #esse método calcula a área
    def area(self):
        return(self.raio * self.raio) * Circulo.pi


    #Método para gerar um novo raio
    def setRaio(self, novo_raio):
        self.raio = novo_raio

    #Método para obter o raio do círculo
    def getRaio(self):
        return self.raio

#criando o objeto circ, uma instância da classe Circulo():

circ = Circulo()

circ.getRaio()

#Criando outro objeto chamado circ1, uma instância da classe Circulo(). Agora sobrescrevendo o valor do atributo
circ1 = Circulo(7)

#Executando um método da classe Circulo
circ1.getRaio()

#Imprimindo o raio default:
print("O raio é: ", circ.getRaio())

#Imprimindo a área:
print("A área do círculo é: ", circ.area())

#Gerando um novo valor para o raio do círculo:
circ.setRaio(3)

#Imprimindo o novo raio:
print("O novo raio é: ", circ.getRaio())

"""Herança de Classes em Python: em POO a herança é um conceito que permite criar novas classes a partir de outras classes existentes, aproveitando os atributos e métodos da classe original e adicionando novos atributos e métodos específicos. A classe original é chamada de classe mãe ou superclasse, e a nova classe criada é chamada de classe filha ou subclasse. A herança é uma técnica importante porque permite reutilizar o código de maneira inteligente. Em vez de criar uma nova classe do zero, a subclasse pode herdar todos os atributos e métodos da superclasse e adicionar apenas o que é necessário. Dessa forma, a subclasse pode se concentrar em fornecer funcionalidades adicionais sem precisar se preocupar com as características básicas da classe. Na herança, uma subclasse pode herdar os atributos e os métodos da superclasse e substituí-los ou estendê-los conforme a necessidade. Por exemplo, uma subclasse pode ter um método com o mesmo nome de um método da superclasse, mas com um comportamento diferente."""

#Criando a classe Animal (superclasse):
class Animal:

    def __init__(self):
        print("Animal criado.")

    def imprimir(self):
        print("Este é um animal.")

    def comer(self):
        print("Hora de comer.")

    def emitir_som(self):
        pass

#Criando a classe cachorro (subclasse):

class Cachorro(Animal):

    def __init__(self):
        Animal.__init__(self)
        print("Objeto cachorro criado.")

    def emitir_som(self):
        print("Au-au!")

#Criando a classe Gato (subclasse):

class Gato(Animal):

    def __init__(self):
        Animal.__init__(self)
        print("Objeto gato criado.")

    def emitir_som(self):
        print("Miau!")

#Criando um objeto (instanciando a classe):
rex = Cachorro()

zeze = Gato()

rex.emitir_som()

zeze.emitir_som()

#Método da classe Animal (superclasse)
rex.comer()

#Método da classe Animal (superclasse)
zeze.comer()

#Executando método da classe cachorro (subclasse):
rex.imprimir()

"""DSA - POLIMORFISMO - Polimorfismo é um conceito chave da POO, pois permite que objetos de diferentes classes possam ser tratados de forma uniforme. Isso significa que um objeto pode ser tratado como se fosse um objeto de uma super classe, mesmo que seja de uma subclasse. Mais especificamente, o polimorfismo se refere à habilidade de um objeto responder de diferentes formas a uma mesma mensagem. Isso é possível porque se subclasses podem implementar métodos com o mesmo nome que os métodos da superclasse, mas com comportamentos diferentes. Com o polimorfismo, os mesmos atributos e métodos podem ser utilizados em objetos distintos, porém, com implementações lógicas diferentes."""

#Superclasse:
class Veiculo:

    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo

    def acelerar():
        pass

    def frear():
        pass

#Subclasse:
class Carro(Veiculo):

    def acelerar(self):
        print("O carro está acelerando!")

    def frear(self):
        print("O carro está freando!")

#Subclasse:
class Moto(Veiculo):

    def acelerar(self):
        print("A moto está acelerando!")

    def frear(self):
        print("A moto está freando!")

#Subclasse:
class Aviao(Veiculo):

    def acelerar(self):
        print("O avião está acelerando!")

    def frear(self):
        print("O avião está freando!")

    def decolar(self):
        print("O avião está decolando!")

#Cria objetos:
lista_veiculos = [Carro("Porche", "911 Turbo"), Moto("Honda", "CB 1000r Black Edition"), Aviao("Boeing", "757")]

#Loop
for item in lista_veiculos:

    #O método acelerar tem comportamento diferente dependendo do tipo de objeto
    item.acelerar()

    #O método frear tem comportamento diferente dependendo do tipo de objeto
    item.frear()

    #Executamos o método decolar somente se o objeto for instância da classe Avião:
    if isinstance(item, Aviao):
        item.decolar()

    print("-" * 180)

"""PYTHON ACADEMY - POO - existe para facilitar a modelagem do mundo real na programação e para isso existem dois conceitos principais: classe e objeto. Classes são moldes para as construções de objetos e definem quais serão os atributos e características destes objetos. Já os objetos são algo material ou abstrato que pode ser descrito por meio das suas caracteísticas, comportamentos e estado atual. Assim sendo, os objetos devem responder a três perguntas, sendo elas: 1 - Que coisas eu tenho? 2 - Que coisas eu faço. 3 - Qual o meu estado atual?

Atributos = O que eu tenho.
Métodos = O que eu faço.
Estado = Qual o meu estado atual?

Essas são características essenciais aos objetos, ja que eles têm que ter atributos, métodos e estado.

Os 4 pilares da POO:

Encapsulamento - isolar/esconder dados em Classes, evitando acesso externo direto aos dados desta Classe. Os dados devem ser modificados apenas pelos métodos contidos na própria classe e isso serve para isolar e encapsular os dados para que nenhum agente externo, outra classe ou outro objeto tenha acesso direto aos dados. Só se altera os atributos de um objeto por meio dos métodos definidos para a sua classe. Em resumo, serve para manter o controle dos dados nas mãos do programador e prevenir acesso indevido aos atributos de uma classe, o que pode acabar levando o nosso programa para um Estado não mapeado.

Abstração - pense, hipoteticamente, em um carro. Características essenciais que o proprietário precisa saber:

1 - Como frear o carro;
2 - Como engatar o carro;
3 - Como desligar o alarme;
4 - Como o volante vira o carro;
5 - Litrso de gasolina;
6 - commo trocar a marcha.

A montadora fornece informações essenciais de como manusear com segurança o carro, entretanto esconde algumas infos que não são relevantes para que ele saiba como manusear seguranmente o seu veículo. Alguma dessas infos são: como o motor funciona, a tecnologia usada nos freios do carro, como os circuitos internos funcionam, qual a linguagem utilizada nos softwares do veículo, quantos litros o limpador do parabrisa possui, qual a fabricante da transmissão etc. Na programação isso se aplica da seguinte maneira - usuários de Classe que você cria não devem se preocupar com os detalhes internos destas Classes. Ex: cel.carregar_aplicativo(Aplicativo:Instagram).

Herança - é o pilar da POO que permite que Classes derivem de outras Classes para aproveitar e reutilizar o código. Por exemplo, se tivéssemos uma classe chamada automóvel, outras classes como carro, moto, caminhão, caminhonete e moto, poderiam herdar da classe automóvel atributos (comportamentos) comuns a essas novas classes diminuindo assim a quantidade de código que por ventura teria que ser implementada do zero para cada uma dessas classes.

Polimorfismo - é a característica que métodos possuem de assumir várias(poli) formas(morfismo). Exemplo: suponha que você tenha que implementar o método gerar_fatura() para cada subtipo de automóvel. Uma moto tem eixo menor e consome menos combustível, paga menor preço em pedágio etc., e tudo isso influencia  o cálculo da fatura de um aluguel de veículo. Assim sendo, temos o mesmo nome de método (gerar_fatura), porém as implementações são diferentes para cada tipo dos subtipos do automóvel. Isto é, herda-se da classe pai, contudo tem uma implementação diferente do método gerar_fatura para cada um dos subtipos do automóvel.

JOGO HANGMAN BASEADO EM POO - PRATICANDO:
"""

# Hangman Game (Jogo da Forca)
# Programação Orientada a Objetos

# Import
import random
from os import system, name

# Função para limpar a tela a cada execução:
def limpa_tela():
    # Windows
    if name == "nt":
        _ = system('cls')
    # Mac ou Linux
    else:
        _ = system('clear')


# Board (tabuleiro)
board = ['''

>>>>>>>>>>Hangman<<<<<<<<<<

+---+
|   |
    |
    |
    |
    |
=========''', '''

+---+
|   |
O   |
    |
    |
    |
=========''', '''

+---+
|   |
O   |
|   |
    |
    |
=========''', '''

 +---+
 |   |
 O   |
/|   |
     |
     |
=========''', '''

 +---+
 |   |
 O   |
/|\  |
     |
     |
=========''', '''

 +---+
 |   |
 O   |
/|\  |
/    |
     |
=========''', '''

 +---+
 |   |
 O   |
/|\  |
/ \  |
     |
=========''']


# Classe
class Hangman:
    # Método Construtor
    def __init__(self, palavra):
        self.palavra = palavra
        self.letras_erradas = []
        self.letras_escolhidas = []

    # Método para adivinhar a letra
    def guess(self, letra):
        if letra in self.palavra and letra not in self.letras_escolhidas:
            self.letras_escolhidas.append(letra)
        elif letra not in self.palavra and letra not in self.letras_erradas:
            self.letras_erradas.append(letra)
        else:
            return False
        return True

    # Método para verificar se o jogo terminou
    def hang_over(self):
        return self.hang_manwon() or (len(self.letras_erradas) == 6)

    # Método para verificar se o jogador venceu
    def hang_manwon(self):
        if '_' not in self.hide_palavra():
            return True
        return False

    # Método para não mostrar a letra no board
    def hide_palavra(self):
        rtn = ''

        for letra in self.palavra:
            if letra not in self.letras_escolhidas:
                rtn += "_"
            else:
                rtn += letra
            return rtn

# Função para escolher uma palavra aleatoriamente
def rand_palavra():
    # Lista de palavras para o jogo
    palavras = ['banana', 'abacate', 'uva', 'morango', 'laranja']
    # Escolhe uma palavra aleatoriamente
    palavra = random.choice(palavras)
    return palavra

# Método main - inicia o programa
def main():
    limpa_tela()
    # Cria o objeto e seleciona uma palavra aleatoriamente
    palavra_aleatoria = rand_palavra()
    game = Hangman(palavra_aleatoria)

    # Enquanto o jogo não estiver terminado, imprime o status e solicita uma letra para adivinhar
    while not game.hang_over():
        # Imprime o status do jogo
        game.hide_palavra()
        print(board[len(game.letras_erradas)])
        print('\nLetras erradas: ', end='')
        for letra in game.letras_erradas:
            print(letra, end=' ')
        print()
        print('Letras corretas: ', end='')
        for letra in game.letras_escolhidas:
            print(letra, end=' ')
        print()

        # Recebe a entrada do usuário
        user_input = input('\nDigite uma letra: ')

        # Verifica se a letra digitada faz parte da palavra
        game.guess(user_input)

    # Verifica o resultado do jogo
    if game.hang_manwon():
        print('\nParabéns! Você venceu!')
    else:
        print('\nGame Over! Você perdeu!')
        print('A palavra era: ' + game.palavra)

    print('\nFoi bom jogar com você! Agora, vá estudar!\n')

# Executa o programa
#Usando o "if __name__" o interpretador saberá que é uma instrução para executar o método "main()"
if __name__ == "__main__":
    main()

"""DSA - INTRODUÇÃO AO NUMPY(Numerical Python) - https://numpy.org/"""

##Instrução para instalar uma versão exata do pacote Numpy em Python
!pip install numpy==1.22.2
# The standard way to import NumPy:
import numpy as np
np.__version__

#Criando arrays em Python
#Array criado a partir de uma lista Python
arr1 = np.array([10, 21, 32, 43, 48, 15, 76, 57, 89])
print(arrl)

#Um objeto do tipo ndarray é um recipiente multidimensional de itens do mesmo tipo e tamanho
type(arr1)

#Verificando o formato do array
arr1.shape

"""Um array Numpy é uma estrutura de dados multidimensional usada em compuntação científica e análise de dados. O Numpy fornece um objeto de Matriz N-dimensional (ou ndarray), que é uma grade homogênea de elementos, geralmente números, que podem ser indexados por um conjunto inteiro. Os arrays Numpy são mais eficientes do que as listas Python para armazenar e manipular grandes quantidades de dados, pois são implementados em linguagem C e fornecem várias otimizações de desempenho. Aleḿ disso, o Numpy permite a fácil leitura e escrita de arquivos de dados, integração com outras bibliotecas Python e suporte a operações em paralelo usando várias CPUs ou GPUs."""

#Imprimindo um elemento específico do array
arr1[4]

#Indexação de arrays Numpy
arr1[1:4]

#indexação
arr1[1:4 + 1]

#Cria uma lista de índices
indices = [1, 2, 5, 6]

#imprimindo os elementos dos índices
arr1[indices]

#Cria uma máscara booleana para os elementos pares
mask_par = (arrl % 2 == 0)
arr1[mask_par]

#máscara para valores ímpares
mask_impar = (arrl % 2 != 0)
arr1[mask_impar]

mask_impar

mask_par

#Alterando elemento do array:
arr1[0] = 100
arr1

#Não é possível incluir elemento de outro tipo
try:
     arr1[0] = 'Novo Elemento'
except:
    print("Operação Não permitida!")

"""TRABALHANDO COM FUNÇÕES NUMPY"""

#A função array() cria um array NumPy
arr2 = np.array([1, 2, 3, 4, 5])
print(arr2)

#Conferindo o tipo do objeto
type(arr2)

#Verificando métodos e atributos
dir(arr2)

#Utilizando alguns métodos do NumPy
arr2.cumsum()

arr2.cumprod()

#A função arange cria um array NumPy contendo uma progressão aritmética a partir de um intervalo start -stop - step
arr3 = np.arange(0, 50, 5)
print(arr3)

#Formato do array:
np.shape(arr3)

print(arr3.dtype)

#Cria um array preenchido com zeros
arr4 = np.zeros(10)
print(arr4)

#Retorna 1 nas posições diagonal e 0 no restante
arr5 = np.eye(3)
print(arr5)

#Os valores passados como parâmetros, formam uma diagonal
arr6 = np.diag(np.array([1, 2, 3, 4]))
print(arr6)

#Array de valores booleanos
arr7 = np.array([True, False, False, True])
print(arr7)

#Array de Strings
arr8 = np.array(['Linguagem Python', 'Linguagem R', 'Linguagem Julia'])
print(arr8)

"""A função linspace() do NumPy é usada para criar uma sequência de números igualmente espaçados dentro de um intervalo especificado. Essa função é amplamente utilizada em programação científica e matemática para gerar arrays de números para diversos fins, como gráficos, cálculos e simulações. O método linspace(linearly spaced vector) retorna um número de valores igualmente distribuídos no intervalo especificado."""

print(np.linspace(0, 10))

print(np.linspace(0, 10, 15))

"""A função logspace() do NumPy é usada para criar uma sequência de números igualmente espaçados em escala logarítmica dentro de um intervalo determinado. Essa função é amplamente utilizada em programação científica e matemática para gerar arrays de números para diversos fins, como gráficos, cálculos e simulações."""

print(np.logspace(0, 5, 10))

"""DSA - MANIPULANDO MATRIZES COM NUMPY"""

import numpy as np
#criando uma matriz
arr9 = np.array ( [ [1, 2, 3], [4, 5, 6] ])

type(arr9)

print(arr9)

#Criando uma matriz 2x3 utilizando apenas numeros 1:
arr10 = np.ones((2, 3))
print(arr10)

#lista de listas
lista = [[13, 81, 22], [0,34, 59], [21, 48, 94]]

# A função matrix cria uma matriz a partir de uma lista de listas
arr11 = np.matrix(lista)
type(arr11)

np.shape(arr11)

print(arr11)

#tamanho da matriz
arr11.size

arr11.dtype

arr11[2,1]

arr11[0:2,2]

arr11[1,]

#Alterando um elemento da matriz
arr11[1,0] = 100
arr11

x = np.array([1,2]) #numpy decide o tipo do dado
y = np.array([1.0, 2.0]) #numpy decide o tipo do dado
z = np.array([1, 2], dtype = np.float64) #Forçando um tipo de dado em particular

print(x.dtype, y.dtype, z.dtype)

arr12 = np.array(([24, 76, 92, 14], [47, 35, 89, 2]), dtype = float)

print(arr12)

"""O itemsize de um array numpy é um atributo que retorna o tamanho em bytes de cada elemento do array. Em outras palavras, o itemsize representa o número de bytes necessários para armazenar cada valor do array numpy."""

arr12.itemsize

arr12.nbytes

arr12.ndim

"""Manipulando Objetos de 3 e 4 Dimensões com NumPy

"""

#Cria um array numpy de 3 dimensões:
import numpy as np

arr_3d = np.array([
  [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
  ],
  [
    [13, 14, 15, 16],
    [17, 18, 19, 20],
    [21, 22, 23, 24]
  ]
])

print(arr_3d)

arr_3d.ndim

arr_3d.shape

arr_3d[0, 2, 1]

import numpy as np

arr_4d = np.array([[[[  1,   2,   3,   4,   5],
                    [  6,   7,   8,   9,  10],
                    [ 11,  12,  13,  14,  15],
                    [ 16,  17,  18,  19,  20]],

                   [[ 21,  22,  23,  24,  25],
                    [ 26,  27,  28,  29,  30],
                    [ 31,  32,  33,  34,  35],
                    [ 36,  37,  38,  39,  40]],

                   [[ 41,  42,  43,  44,  45],
                    [ 46,  47,  48,  49,  50],
                    [ 51,  52,  53,  54,  55],
                    [ 56,  57,  58,  59,  60]]],

                  [[[ 61,  62,  63,  64,  65],
                    [ 66,  67,  68,  69,  70],
                    [ 71,  72,  73,  74,  75],
                    [ 76,  77,  78,  79,  80]],

                   [[ 81,  82,  83,  84,  85],
                    [ 86,  87,  88,  89,  90],
                    [ 91,  92,  93,  94,  95],
                    [ 96,  97,  98,  99, 100]],

                   [[101, 102, 103, 104, 105],
                    [106, 107, 108, 109, 110],
                    [111, 112, 113, 114, 115],
                    [116, 117, 118, 119, 120]]]])

print(arr_4d)

arr_4d.ndim

arr_4d.shape

arr_4d[0, 2, 1]

arr_4d[0, 2, 1, 4]

"""DSA - Manipulando arquivos com Numpy"""

import numpy as np
import os
file_path = os.path.join('/content/sample_data', 'dataset.csv')
!head dataset.csv #comando de linux ou macos para visualizar o arquivo - não é comando python.

import numpy as np

# Caminho completo para o arquivo
file_path = '/content/dataset.csv'

# Carregar o arquivo CSV usando NumPy
arr13 = np.loadtxt(file_path, delimiter=',', usecols=(0, 1, 2, 3), skiprows=1)

# Imprimir o array carregado
print(arr13)

#Carregando apenas duas colunas (variaveis) do arquivo
var1, var2 = np.loadtxt(file_path, delimiter=',', usecols=(0, 1), skiprows=1, unpack=True)
#Gerando um plot por meio de um arquivo numpy
import matplotlib.pyplot as plt
plt.show(plt.plot(var1, var2, 'o', markersize = 6, color = 'brown'))

"""Análise Estatística Básica com NumPy

Em estatística, a média é uma medida de tendência central que representa o valor central de um conjunto de dados. É calculada somando-se todos os valores do conjunto de dados e dividindo-se pelo número de observações.
"""

import numpy as np
arr14 = np.array([15,23,63,94,75])
np.mean(arr14)

"""O desvio padrão é uma medida estatística de dispersão que indica o quanto os valores de um conjunto de dados se afastam da média. Ele é calculado como a raíz quadrada da variância, que é a média dos quadrados das diferenças entre cada valor e a média. É uma medida útil porque permite avaliar a variabilidade dos dados em torno da média. Se os valores estiverem próximos da média, o desvio padrão será baixo, indicando que os dados têm pouca variabilidade. Por outro lado, se os valores estiverem muito distantes da média, o desvio padrão será alto, indicando que os dados têm alta variabilidade. O desvio padrão é amplamente utilizado em Análise de Ciência de Dados, para avaliar a consistência dos dados e comparar conjuntos de dados diferentes. É importante notar que o desvio padrão pode ser influenciado por valores extremos (Outliers) e pode ser afetado por diferentes distribuições de dados."""

#Desvio Padrão - Standard Deviation
np.std(arr14)

"""A variância é uma medida estatística que quantifica a dispersão dos valores em um conjunto de dados em relação à média. ela é claculada como a média dos quadrados das diferenças entre cada valor e a média. A fórmula para o cálculo da variância é: Variância (σ²) = Σ [(xi - μ)²] / N

Onde:

σ² é a variância.
Σ denota a soma.
xi são os valores individuais no conjunto de dados.
μ é a média do conjunto de dados.
N é o número total de valores no conjunto de dados.
No entanto, note que existe uma pequena discrepância na sua mensagem. A fórmula não foi exibida completamente. A fórmula completa para o cálculo da variância é:

Variância (σ²) = Σ [(xi - μ)²] / N

O quadrado das diferenças entre cada valor individual (xi) e a média (μ) é somado e, em seguida, dividido pelo número total de valores (N) para obter a variância. A raiz quadrada da variância é o desvio padrão (σ), que é uma medida comum usada para expressar a dispersão de forma mais intuitiva, pois está na mesma unidade dos dados originais.

Lembre-se de que a variância pode ser sensível a valores extremos, assim como o desvio padrão. Portanto, ao interpretar e analisar essas medidas, é importante considerar a natureza dos dados e o contexto da análise.
"""

#Calcular a variância
np.var(arr14)

"""Quando Usar Desvio Padrão ou Variância? Tanto a variância quanto o desvio padrão são medidas úteis de dispersão e podem ser usados em conjunto para descrever a distribuição de um conjunto de dados.Avariância é uma medida quadrática e pode ser útil para calcular outras estatísticas, como o desvio padrão. No entanto, como a variância é uma medida quadrática, seus valores são geralmente maiores do que os valores dos próprios dados, o que pode dificultar a interpretação. O desvio padrão é a raiz quadrada da variância e fornece uma medida de dispersão que tem a mesma unidade de medida que os próprios dados, facilitando a interpretação e a comparação com outros valores.Em geral, o desvio padrão é mais comumente usado do que a variância, principalmente porque é mais fácil de interpretar. No entanto, a escolha entre o uso da variância ou do desvio padrão depende do contexto e do objetivo da análise. Em alguns casos, a variância pode ser uma medida  mais  apropriada,  como  quando  se  pretende  calcular  outras  estatísticas,  como  a covariância ou o coeficiente de correlação. Em outros casos, o desvio padrão pode ser uma medida mais apropriada, como quando se pretende avaliar a consistência dos dados em relação à média e comparar diferentes conjuntos de dados.

CURSO PYTHON PARA DATA SCIENCE A MACHINE LEARNING AZIMOV

### Exercício 2
Escreva um script que leia três números e mostre o maior e o menor deles.
"""

### Exercício 2
list_nums = []
for i in range(3):
    print("informe o {}º número: ".format(i + 1))
    x = int(input())
    list_nums.append(x)
list_nums.sort()
print("O maior número é {}.".format(list_nums[-1]))
print("O maior número é {}.".format(list_nums[0]))

"""### Exercício 3
Nome na vertical em escada.

F<br>
FU<br>
FUL<br>
FULA<br>
FULAN<br>
FULANO<br>

# Nova seção
"""

nome = input("Informe o nome:")
print("=" * 50)
for i in range(len(nome) + 1):
    print(nome[:i])

"""### Exercício 4
A série de Fibonacci é formada pela seqüência 1,1,2,3,5,8,13,21,34,55,... (o próximo termo, a partir do terceiro, é sempre gerado a partir do somatório dos últimos dois). Faça um programa capaz de gerar a série até o n−ésimo termo (onde o valor n deve ser inserido pelo usuário).
"""

n = int(input("Qual o tamanho da sequência de Fibonancci você deseja ver? "))

v0 = 0
v1 = 1
v = 1
print("========================")
print(1)
for i in range(n+1):
    print(v)
    v0 = v1
    v1 = v
    v = v1 + v0

"""### Exercício 5
Faça um programa que leia e valide as seguintes informações:
- Nome: maior que 3 caracteres;
- Idade: entre 0 e 150;
- Salário: maior que zero;
- Sexo: 'f' ou 'm';
- Estado Civil: 's', 'c', 'v', 'd';
"""

while True:
    try:
        nome = input("Informe o nome: ")
        if len(nome) < 3:
            print("O nome deve conter mais de 3 caracteres.")
        idade = int(input("Diga sua idade: "))
        if (idade < 0) or idade > 150:
            print("Digite uma idade real.")
        salario = int(input("Digite seu salário: "))
        if salario < 0:
            print("Além de burro você é escravo!")
        sexo = input("Digite seu sexo (m/f): ").lower()
        if sexo != 'm' or sexo != 'f':
            print("Por favor, somente masculino e feminino.")
        break
    except:
        print("Error")

"""### Exercício 6
Faça um programa que peça um número inteiro e determine se ele é ou não um número primo. Um número primo é aquele que é divisível somente por ele mesmo e por 1.
Dica: Utilize o operador aritmético `%`, que retorna o resto da divisão de dois números.
"""

numero = int(input("Digite um número: "))
if (numero % 2) == 0:
    print("é primo!")
else:
    print("Não é primo!")

num = int(input("Enter an integer: "))

# Check if the number is greater than 1
if num > 1:
    for i in range(2, num):
        # Check if the number is divisible by any number between 2 and itself
        if (num % i) == 0:
            print("{} is not a prime number.".format(num))
            break
    else:
        print("{} is a prime number.".format(num))
else:
    print("{} is not a prime number.".format(num))

#Biblioteca para debug:
import pdb
x = [1, 2, 3]
y = 4
z = 5
pdb.set_trace() #exemplo de como rastrear e saber o erro, embora no exemplo o erro seja simples de entender
#comando c dentro do pdb avança até o prox pdb, caso tenha, e se nao tiver volta ao codigo
#comando comando q encerra a execução
print(z + x)

#AZIMOV - TRATANDO ERRO:
try:
    x = [1, 3, 4]
    y = 2
    z = 5
    print(y + x)
except Exception as e: # guarda o erro em uma variável
    print(e)
finally: # O finally: o bloco de código sempre será executado, independentemente de existir uma exceção no bloco de código try
    print("Deu ruim!")

"""Logging é o processo de registrar eventos que ocorrem ao longo da execução de um
software. É uma ferramenta importantíssima para qualquer programador, permitindo a ele
obter um profundo conhecimento sobre o funcionamento de seu código, localizar bugs e
otimizar seu script. Há muitas formas de executar logging de seu código e aqui,
aprenderemos a como usar o módulo padrão do Python.
Uso básico
A importação do módulo é bem simples, e não precisa de instalações adicionais.
O módulo fornece uma forma simples para que os aplicativos configurarem diferentes
manipuladores de log e uma maneira de enviar mensagens de log para esses manipuladores.
Isso permite um setup flexível que pode lidar com muitos casos de uso diferentes.
Para registrarmos nossos logs, primeiramente instanciamos um objeto responsável por
manipular estes registros através do método logging.getLogger . Através destes
objetos, podemos criar formas para nosso programa lidar diferentes tipos de logs.
Níveis de logging
Nem todas as mensagens de log são iguais. Ao definir um nível de registro em Python
usando o módulo padrão, você está informando à biblioteca que deseja lidar com todos os
eventos desse nível em diante. Se você definir o nível de log para INFO, ele incluirá as
mensagens INFO, WARNING, ERROR e CRITICAL. As mensagens NOTSET e DEBUG não
serão incluídas aqui.
"""

import logging
from google.colab import files
LOG_FORMAT = "%(levelname)s", "%(asctime)s", "%(message)s"

logging.basicConfig(filename="app.log", level=logging.DEBUG, filemode="w", format=LOG_FORMAT)
log = logging.getLogger()
log.info("Olá!")
log.level

!find / -name app.log
!cat /var/colab/app.log

nome = input("Nome?" )
for i in range(len(nome) + 1):
    print(nome[:i])

"""INTRODUÇÃO À POO"""

#Exemplo básico de objetos e classes
l = [1, 2, 3] # a lista é um objeto que deriva da classe lista e tem seus prórpios métodos
#exemplo de métod(append)
l.append(4)
print(type(l))
#estrutura básica de como criar classe:
class exemplo:
    pass
x = exemplo()
print(type(exemplo))

#Criando classes e métodos - tudo dentro da classe precisa residir dentro de um método e os métodos são criados dentro das classes da mesma forma que são criados fora dela(usando a palavra def)
class Dog:

    def __init__(self, raca): #pode também passar parâmetro, como p. ex, "raça" (self, raça), mas o self sempre tem que vir antes de tudo
        self.raca = raca
        self.idade = 10
        print(f"{raca} criado!")

        #criando os métodos da classe:

    def envelhecer(self): #poderia ter retorno e vc é livre para fazer como quiser o método
        self.idade += 1

#dog = Dog()
#dog.idade #acessando a classe
#Alterando
#dog.idade = 11
#dog.idade
dog = Dog('Labrador')
dog.envelhecer() # aqui adiciona 1 ano a mais na idade do cachorro, porque é o que faz o método
#dog.envelhecer() se o método for chamado de novo, antes da idade, envelhece mais um ano
print(dog.idade)
print(dog.raca)

#aqui não houve alteração
dog2 = Dog("Huskie")
print(dog2.idade)
print(dog2.raca)

#Exemplo de criação de classe do tipo circulo:
from math import pi
class circle:
    def __init__(self, raio=1): #caso o usuário não passe o parâmetro raio, automaticamente o parâmetro será definido como tendo valor "1".
        self.raio = raio
    #método para calcular área:
    def calcula_area(self):
        return self.raio * self.raio * pi
    def retorna_raio(self):
        return self.raio

c1 = circle()
c2 = circle(2)
print(c1.raio)
print(c2.raio)
print(round(c1.calcula_area(), 3))
print(f"{c1.calcula_area():.3f}")
print("{:.3f}".format(c1.calcula_area()))

"""Herança -
herança é uma forma de formar novas classes usando classes que já foram definidas. As
classes recém formadas são chamadas classes derivadas, as classes de que derivamos são
chamadas de classes base. Os benefícios importantes da herança são a reutilização de
In [7]:
sam.species
Out[7]:
In [1]:
class Circle(object):
pi = 3.14
# O círculo é instanciado com um raio (o padrão é 1)
def __init__(self, radius=1):
self.radius = radius
# Método de cálculo da área. Observe o uso de si mesmo.
def area(self):
return self.radius * self.radius * Circle.pi
# Método que redefine a área
def setRadius(self, radius):
self.radius = radius
# Método para obter raio (Mesmo que apenas chamar .radius)
def getRadius(self):
return self.radius
c = Circle()
c.setRadius(2)
print('O raio é :',c.getRadius())
print('A área é',c.area())códigos e a redução da complexidade de um programa. As classes derivadas
(descendentes) substituem ou estendem a funcionalidade das classes base (ancestrais).
Vejamos um exemplo incorporando nosso trabalho anterior na classe Dog:
"""

#Exemplo:

class Animal:
    def __init__(self):
        print("Animal criado!")


    def quem_sou_eu(self):
        return "Eu sou um animal."


    def comer(self):
        return "Comendo."



animal = Animal()
print(animal.quem_sou_eu())
print(animal.comer())

class Cachorro(Animal): # está herdando de animal todos os atributos
    def __init__(self):
        Animal.__init__(self)
        print("Eu sou um cachorro.")

    def quem_sou_eu(self): # só modifiquei este método
        return "Eu sou um cachorro."

dog = Cachorro()
print(dog.quem_sou_eu())
print(dog.comer())

"""Métodos especiais -
finalmente, vamos dar uma olhada em métodos especiais. Classes em Python podem
implementar determinadas operações com nomes de métodos especiais. Esses métodos
não são realmente chamados diretamente, mas pela sintaxe de linguagem específica de
Python.

"""

#exemplo:

class Book(object):

    def __init__(self, title, author, pages):
        print("A book is created")
        self.title = title
        self.author = author
        self.pages = pages

    def __str__(self): #qdo for dar print na instancia da classe, busca pelo que tem aqui dentro e printa
        return "Title:%s , author:%s, pages:%s " %(self.title, self.author, self.pages)

    def __len__(self): #caso use a função len, retornar-se-á a quantidade do numero de páginas
        return self.pages

    def __del__(self): #função que será usada caso há a necessidade de destruição da variável
        print("A book is destroyed")

book = Book("Python Rocks!", "Rodrigo Tadewald", 159) #livro instanciado com as informações necessárias
# Métodos especiais
print(book)
print(len(book))
del book #deleta a variável e a limpa da memória

"""Os métodos init (), str (), len () e del (). Esses métodos especiais são definidos pelo uso de
sublinhados. Eles nos permitem usar funções específicas do Python em objetos criados
através da nossa classe.

PROJETO LOCADORA DE CARROS
"""

import os

header = "=" * 100
texto = "Bem vindo(a) à locadora de carros Vitor Campos"
print(header)
print(texto.center(len(header)))
print(header)

carros = [
    ("Chevrolet Tracker", 120),
    ("Chevrolet Onix", 90),
    ("Chevrolet spin", 150),
    ("Hyundai HB20", 85),
    ("Hyundai Tucson", 120),
    ("Fiat Uno", 60),
    ("Fiat Mobi", 70),
    ("Fiat Pulse", 130)
    ]
alugados = []

def mostar_lista_de_carros(lista_de_carros):
    for i, car in enumerate(lista_de_carros):
        print("({}) {} - R$ {},00 por dia.".format(i, car[0], car[1]))

while True:
    try:
        print("O que deseja fazer?")
        print("Aperte: 0 - Portifólio | 1 - Alugar carro | 2 - Devolver carro | 3 - sair")
        op = int(input())

        if op == 0:
            mostar_lista_de_carros(carros)
        elif op == 1:
            mostar_lista_de_carros(carros)
            print('=' * 100)
            print("Escolha o código do carro: ")
            cod_car = int(input())
            print("Por quantos dias você deseja alugar este carro? ")
            dias = int(input())

            print("Voce escolheu alugar o {} por {} dias.".format(carros[cod_car][0], dias))
            print("O aluguel totaliza em R$ {}.".format(dias * carros[cod_car][1]))
            print("0 - SIM | 1 - NÃO")
            conf = int(input())

            if conf == 0:
                print("Parabéns você alugou o {} por {} dias.".format(carros[cod_car][0], dias))
                alugados.append(carros.pop(cod_car))

        elif op == 2:
            if len(alugados) == 0:
                 print("Não há carros para devolver!")
            else:
                print("Segue a lista de carros alugados. Qual você deseja devolver? ")
                mostar_lista_de_carros(alugados)
                print("")
                print("Escolha o código do carro que deseja devolver: ")
                cod = int(input())
                conf = input("Você tem certeza de que deseja devolver o carro {}? (S/N)".format(alugados[cod][0]))
                if conf.upper() == "S":
                    print("Obrigado por devolver o carro {}.".format(alugados[cod][0]))
                    carros.append(alugados.pop(cod))
                else:
                    continue
        elif op == 3:
            print("Conte sempre conosco. Volte Sempre!")
            break
        else:
            print("Opção inválida.")
            continue
    except ValueError:
        print("Por favor, digite um número inteiro.")
        continue
    except IndexError:
        print("Por favor, digite um código válido.")
        continue

import pandas as pd

# The name of the file can be specified as a string
file_name = "cafe.xls"

# Use the `read_excel` method to import the file
df = pd.read_excel(file_name)




# Remove rows with index from 0 to 49 (inclusive)
#df.drop(df.index[18:27], inplace=True)
#df.drop(df.index[28], inplace=True)
#df.drop(df.index[61:67], inplace=True)
#df.drop(df.index[68:85], inplace=True)
#df.drop(df.index[86:173], inplace=True)
#df.drop(df.index[174:181], inplace=True)
#df.drop(df.index[182:200], inplace=True)
#df.drop("Unnamed: 0.1", axis=1, inplace=True)
#df.rename(columns={df.columns[1]: "Dados"}, inplace=True)
df = df.rename(columns={'aqui':'Dados'})
df["Dados"] = df["Dados"].astype(str).str.lower()
df.drop_duplicates(subset ="Dados", keep = False, inplace = True)

df.drop(df[~df['Dados'].str.contains("https")].index, inplace=True)


columns_to_keep = ['Dados']
df = df[columns_to_keep]

# Print the modified DataFrame
display(df)
#Save the modified dataframe to a new excel file

df.to_excel('cafe1.xls')

from selenium import webdriver
options = webdriver.ChromeOptions()
options.add_argument('--headless')
options.add_argument('--no-sandbox')
options.add_argument('--disable-dev-shm-usage')
navegador = webdriver.Chrome('chromedriver',chrome_options=options)
navegador.get('https://www.google.com')

"""Exercício Comandos Básico curso Uninter python para Iniciantes:
Leia 3 notas de um aluno e informe sua média (0-10)

"""

import random
a = random.randint(1, 10)
b = random.randint(11, 21)
c = random.randint(22, 31)
d = random.randint(32, 42)
e = random.randint(43, 51)
f = random.randint(52, 60)
print(f"Números mega sena da virada: {a}, {b}, {c}, {d}, {e}, {f}")

pip install selenium

import requests
from bs4 import BeautifulSoup

# Define a pesquisa que será realizada
query = "oficina troca de óleo Belo Horizonte"

# Cria a URL de pesquisa utilizando o formato esperado pelo Google
url = f"https://www.google.com/search?q={query}"

# Envia uma solicitação para a URL da pesquisa
response = requests.get(url)

# Verifica se a solicitação foi bem-sucedida
if response.status_code == 200:
    # Carrega o conteúdo HTML da página em um objeto BeautifulSoup
    soup = BeautifulSoup(response.content, "html.parser")

    # Encontra todos os elementos da página com a classe "g"
    elements = soup.find_all(class_="g")

    # Itera sobre cada elemento encontrado
    for element in elements:
        # Encontra o título da página
        title_element = element.find(class_="r")
        if title_element:
            title = title_element.text

        # Encontra o link da página
        link_element = element.find("a")
        if link_element:
            link = link_element["href"]

        # Encontra o snippet da página
        snippet_element = element.find(class_="s")
        if snippet_element:
            snippet = snippet_element.text

        # Imprime os dados encontrados
        print(f"Título: {title}")
        print(f"Link: {link}")
        print(f"Snippet: {snippet}")
        print()

else:
    print("A solicitação falhou.")

# Método que solicita uma letra ao jogador
def get_letter():
    letter = input("Escolha uma letra: ")
    while not letter.isalpha() or len(letter) != 1:
        print("Por favor, escolha apenas uma letra do alfabeto")
        letter = input("Escolha uma letra: ")
    return letter.lower()

# Método que atualiza o estado do jogo
def update_game_state(word, correct_letters, incorrect_letters):
    # Verifica se o jogador ganhou
    if all(letter in correct_letters for letter in word):
        return 1

    # Verifica se o jogador perdeu
    if len(incorrect_letters) == 6:
        return 2

    # O jogo ainda não acabou
    return 0

# Método principal
def main():
    word = "casa" # palavra secreta
    correct_letters = [] # letras corretas adivinhadas
    incorrect_letters = [] # letras incorretas adivinhadas

    # Loop principal do jogo
    while True:
        # Imprime o estado atual do jogo
        print("Palavra: ", end="")
        for letter in word:
            if letter in correct_letters:
                print(letter, end=" ")
            else:
                print("_", end=" ")
        print("\nLetras incorretas: ", end="")
        print(" ".join(incorrect_letters))

        # Solicita uma letra ao jogador
        letter = get_letter()

        # Verifica se a letra está na palavra secreta
        if letter in word:
            correct_letters.append(letter)
        else:
            incorrect_letters.append(letter)

        # Atualiza o estado do jogo
        result = update_game_state(word, correct_letters, incorrect_letters)
        if result == 1:
            print("Parabéns, você ganhou!")
            break
        elif result == 2:
            print("Infelizmente você perdeu :(")
            break

# Inicia o jogo
main()

# Método que imprime o tabuleiro no console
def print_board(board):
    for row in board:
        for col in row:
            if col == 0:
                print("  ", end="") # casa vazia
            elif col == 1:
                print("X ", end="") # peça preta
            else:
                print("O ", end="") # peça branca
        print()

# Método que verifica se a jogada é válida
def is_valid_move(board, from_row, from_col, to_row, to_col):
    # Verifica se as posições de origem e destino são válidas
    if from_row < 0 or from_row > 7 or from_col < 0 or from_col > 7:
        return False
    if to_row < 0 or to_row > 7 or to_col < 0 or to_col > 7:
        return False

    # Verifica se a peça de origem é do jogador atual
    if board[from_row][from_col] != player:
        return False

    # Verifica se a casa de destino está vazia
    if board[to_row][to_col] != 0:
        return False

    # Verifica se a jogada é uma jogada simples (somente avançar uma casa)
    if player == 1 and to_row == from_row - 1 and abs(to_col - from_col) == 1:
        return True
    if player == 2 and to_row == from_row + 1 and abs(to_col - from_col) == 1:
        return True

    # Verifica se a jogada é uma jogada de captura (pulando uma peça inimiga)
    if player == 1 and to_row == from_row - 2 and abs(to_col - from_col) == 2:
        if board[from_row - 1][from_col + 1 if from_col < to_col else from_col - 1] == 2:
            return True
    if player == 2 and to_row == from_row + 2 and abs(to_col - from_col) == 2:
        if board[from_row + 1][from_col + 1 if from_col < to_col else from_col - 1] == 1:
            return True

    return False

# Método que realiza uma jogada
def move(board, from_row, from_col, to_row, to_col):
    # Verifica se a jogada é válida
    if not is_valid_move(board, from_row, from_col, to_row, to_col):
        return False

    # Realiza a jogada
    board[to_row][to_col] = player
    board[from_row][from_col] = 0

        # Verifica se é possível realizar uma captura em sequência (damas)
    if player == 1 and to_row > 1:
        if board[to_row - 1][to_col + 1] == 2 and board[to_row - 2][to_col + 2] == 0:
            move(board, to_row, to_col, to_row - 2, to_col + 2)
        elif board[to_row - 1][to_col - 1] == 2 and board[to_row - 2][to_col - 2] == 0:
            move(board, to_row, to_col, to_row - 2, to_col - 2)
    if player == 2 and to_row < 6:
        if board[to_row + 1][to_col + 1] == 1 and board[to_row + 2][to_col + 2] == 0:
            move(board, to_row, to_col, to_row + 2, to_col + 2)
        elif board[to_row + 1][to_col - 1] == 1 and board[to_row + 2][to_col - 2] == 0:
            move(board, to_row, to_col, to_row + 2, to_col - 2)

    return True

# Método que verifica se o jogo acabou
def game_over(board):
    # Verifica se o jogador branco ganhou
    if not any(2 in row for row in board[:3]):
        return 2

    # Verifica se o jogador preto ganhou
    if not any(1 in row for row in board[5:]):
        return 1

    # Verifica se o tabuleiro está cheio
    if all(x != 0 for row in board for x in row):
        return 0

    # O jogo ainda não acabou
    return -1

# Método que solicita uma jogada ao jogador
def get_move():
    from_row = int(input("Linha de origem (0-7): "))
    from_col = int(input("Coluna de origem (0-7): "))
    to_row = int(input("Linha de destino (0-7): "))
    to_col = int(input("Coluna de destino (0-7): "))
    return from_row, from_col, to_row, to_col

    # Método principal
    def main():
        # Cria o tabuleiro inicial
        board = [[0, 1, 0, 1, 0, 1, 0, 1],
                 [1, 0, 1, 0, 1, 0, 1, 0],
                 [0, 1, 0, 1, 0, 1, 0, 1],
                 [0, 0, 0, 0, 0, 0, 0, 0],
                 [0, 0, 0, 0, 0, 0, 0, 0],
                 [2, 0, 2, 0, 2, 0, 2, 0],
                 [0, 2, 0, 2, 0, 2, 0, 2],
                 [2, 0, 2, 0, 2, 0, 2, 0]]

        # Variável que controla o jogador atual (1 = preto, 2 = branco)
        global player
        player = 1

        # Loop principal do jogo
        while True:
            # Imprime o tabuleiro
            print_board(board)

            # Solicita uma jogada ao jogador
            from_row, from_col, to_row, to_col = get_move()

            # Realiza a jogada
            if not move(board, from_row, from_col, to_row, to_col):
                print("Jogada inválida")
                continue

            # Verifica se o jogo acabou
            result = game_over(board)
            if result != -1:
                print_board(board)
                if result == 0:
                    print("Empate!")
                else:
                    print("Jogador {} ganhou!".format(result))
                break

            # Muda o jogador atual
            player = 1 if player == 2 else 2

    # Inicia o jogo
    main()

import smtplib

# Dados do e-mail
from_address = "vitorbeatle@gmail.com"
to_address = "vitorcamposmouracosta@gmail.com"
subject = "Teste"
body = "Olá, isso é um teste."

# Formata o e-mail como uma string
email = f"From: {from_address}\nTo: {to_address}\nSubject: {subject}\n\n{body}"

# Cria uma conexão com o servidor SMTP
server = smtplib.SMTP("smtp.gmail.com")

# Faz login no servidor
server.login("vitorbeatle@gmail.com", "64954382alorsondanse")

# Envia o e-mail
server.sendmail(from_address, to_address, email)

# Fecha a conexão com o servidor
server.quit()

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Dados do gráfico
x = [1, 2, 3]
y = [2, 3, 1]
z = [3, 1, 2]

# Cria o gráfico 3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Plota os dados no gráfico
ax.scatter(x, y, z)

# Exibe o gráfico
plt.show()

# Habilita a interatividade
ax.mouse_init()

"""Mega sena com lista:"""

import random
import numpy as np

lista = []
x = 1
while x <= 6:
  numeros = random.randint(1, 60)
  lista.append(numeros)
  x += 1

print(lista)

for n in lista:
    if lista[0] == lista[1]:
        lista[0] = random.sample(range(1, 60), 1)
    elif lista[1] == lista[2]:
        lista[1] = random.sample(range(1, 60), 1)
    elif lista[2] == lista[3]:
        lista[2] = random.sample(range(1, 60), 1)
    elif lista[4] == lista[5]:
        lista[4] = random.sample(range(1, 60), 1)

print(f"Numeros da mega: {lista}")

for n in lista:
    lista[0] = random.sample(range(1, 10), 1)
    lista[1] = random.sample(range(11, 21), 1)
    lista[2] = random.sample(range(22, 32), 1)
    lista[3] = random.sample(range(33, 43), 1)
    lista[4] = random.sample(range(44, 54), 1)
    lista[5] = random.sample(range(55, 60), 1)

print(lista)



print(list(np.random.randint(low = 1,high=60,size=6)))

y = input()
x = input()
print(x + y)

"""Exercicio média ponderada relativa a três notas de um aluno cujos pesos são 1, 3 e 5."""

x = float(input("Digite sua 1ª nota: "))
z = float(input("Digite sua 2ª nota: "))
y = float(input("Digite sua 3ª nota: "))
media_ponderada = (x*1) + (z*3) + (y*5)
media_final = media_ponderada / 9 #( o 9 é relativo à soma dos pesos)
# 3 formas de saída:
print(f"Sua média ponderada final é:{media_final: .1f}")
print("Sua média ponderada final é: {:.1f}".format(media_final))
print("Sua média ponderada final é:",round(media_final,1))

"""Imprima a área de um círculo: pi vezes o raio elevado ao quadrado (A = π r²).

"""

import math
raio = float(input("Digite um raio: "))
area = math.pi * (raio**2)
print(f"A área é: {round(area,1)}")

"""Imprima a Letra F somente com ########."""

print("#######\n#\n#\n#######\n#\n#\n#\n#")

"""Pergunte ao usuário quantos anos, meses e dias ele viveu. E então responda o total de dias vividos por ele. Paara simplificar, assuma todo o ano com 365 dias e todo mês com 30 dias."""

anos = int(input("Quantos anos você viveu? "))
dias = (anos * 365)
meses = (anos * 12)
print(f"Você viveu {dias: .1f} dias e {meses: .1f} meses.")

"""Assuma que uma pessoa efetuou um empréstimo e que a multa por dia de atraso do pgto é de 2%. Pergunte ao usuário o valor emprestado, o total de dias e informe o valor final que deve ser pago. Utilize juros simples:"""

emprestimo = float(input("Digite o valor de empréstimo: "))
atraso = float(input("Digite quantos dias de atraso: "))
multa = 0.02 * atraso
calculo_multa = (multa * emprestimo)
print("Sua multa está no valor de: R$ {:.0f}".format(calculo_multa))
total = calculo_multa + emprestimo
print("O valor total a ser pago é: {:.0f}".format(total))

"""Curso extensivo Uninter Python para iniciantes - Desvio Lógico(condicionais)"""

#Par ou ímpar
num = int(input("Digite um número: "))
if num % 2 == 0:
    print(f"O número {num} é par.")
else:
    print(f"O número {num} é ímpar.")

# if aninhado
# três situações, ou x é > y, ou é =, ou y é >.
x = int(input("Digite um valor: "))
y = int(input("Digite outro valor: "))
if x > y:
    print("x é maior que y.")
else:
    if y > x:
        print("y é maior do que x.")
    else:
        print("x é igual a y.")

#elif

x = int(input("Digite um valor: "))
y = int(input("Digite outro valor: "))

if x > y:
    print("x é maior que y.")
elif y > x:
        print("y é maior do que x.")
else:
        print("x é igual a y.")

"""Exercícios - Leia 3 valores representando notas em uma matéria. Aprovado se as 3 notas forem maior ou igual a 7, senão reprovado."""

print("Bem vindo aluno!\nPara ser aprovado você não pode ter nenhuma das 3 notas abaixo de 7.\nBoa sorte!")
nota_1 = float(input("Digite sua 1ª nota: "))
nota_2 = float(input("Digite sua 2ª nota: "))
nota_3 = float(input("Digite sua 3ª nota: "))
if (nota_1 >= 7) and (nota_2 >=7) and (nota_3 >= 7):
    print("Parabéns 👏👏👏👏👏👏👏👏👏\nVocê foi aprovado 😀")
else:
    print("Infelizmente você não alcançou a pontuação necessária para a sua aprovação 😰. Tente novamente :).")

"""Verifique se dois numeros digitados pelo usuário são múltiplos entre si:"""

n_1 = int(input("Digite o 1º número: "))
n_2 = int(input("Digie o 2º número: "))
if n_1 % n_2 == 0 or n_2 % n_1 == 0:
    print("Esses números são múltiplos!")
else:
    print("Não são múltiplos!")

"""Dados os itens e valores abaixo, perguntar qual item e quantidade de intens para enfim devolver o valor final.
Maça = 2.3
Laranja = 3.6
Banana = 1.85
"""

print("Bem vindo(a) ao sacolão Vitor Campos!")
maça = 2.3
banana = 1.85
laranja = 3.6

while True:
    try:
      item = input("Qual fruta deseja comprar?\nMaça;\nLaranja;\nBanana?\nDigite(s) para sair.").lower()
      if item == 's':
        print("Você digitou 's'. Encerrando o programa!")
        break
      else:
        quantidade = int(input("Digite quantas unidades pretende adquirir: "))
      if item == 'maçã':
        preço_maça = maça * quantidade
        print(f"O valor a pagar é: R${preço_maça: .2f}.")
      elif item == 'banana':
        preço_banana = banana * quantidade
        print(f"O valor a pagar é: R${preço_banana: .2f}.")
      elif item == 'laranja':
        preço_laranja = quantidade * laranja
        print(f"O valor a pagar é: R${preço_laranja: .2f}.")
    except:
          print("Digite dados validos!")
    continue

"""Leia 3 números e diga qual deles é o maior e, caso haja números iguais, informe:"""

num_1 = int(input("Digite o 1º número: "))
num_2 = int(input("Digite o 2º número: "))
num_3 = int(input("Digite o 3º número: "))

if (num_1 > num_2) and (num_1 > num_3):
    print(f"O número {num_1} é o maior dentre os três.")
elif (num_2 > num_1) and (num_2 > num_3):
    print(f"O {num_2} número é o maior dentre os três.")
elif num_3 > num_1 and num_3 > num_2:
    print(f"O {num_3} é o maior dentre os três.")
elif num_1 == num_2 and num_1 == num_3:
    print(f"Você digitou os números {num_1}, {num_2} e {num_3}, portanto, somente números iguais!")
elif num_1 == num_2 and num_3 < num_1:
    print(f"Os números {num_1} e {num_2} são iguais e o terceiro número digitado '{num_3}' é o menor dentre os três números.")
elif num_3 == num_2 and num_2 > num_1:
    print(f"Os números {num_2} e {num_3} são iguais, mas o primeiro número digitado {num_1} é o menor dentre os três números.")

"""Exercício Comandos Básico curso Uninter python para Iniciantes: Leia 3 notas de um aluno e informe sua média (0-10). Use condicionais para dizer se o aluno foi aprovado ou reprovado."""

x = float(input("Digite sua 1ª nota: "))
z = float(input("Digite sua 2ª nota: "))
y = float(input("Digite sua 3ª nota: "))
media = (x + y + z) / 3
if media < 7:
    print(f"Sua nota final foi:{media: .1f}. Reprovado!")
else:
    media >= 7
    print(f"Sua nota final foi:{media: .1f}. Aprovado!")

"""Leia um caracter do teclado e informe se é letra, número ou símbolo:

"""

caracter = input("Digite um caracter: ")
ascii = ord(caracter)
if (ascii >=65 and ascii <= 90) or (ascii > 97 and ascii <=122): # Só lê se a letra for maiúscula
    print("É uma letra!")
elif ascii >= 48 and ascii <=57:
    print("É um número!")
else:
    print("É um símbolo!")

"""Modulo 3 - Curso Python para Iniciantes - Uninter
Laços de Repetição
"""

# Executar 5 vzs o print bom dia!
for i in range(0, 5, 1): # 0 início. 5 alcanse. 1 passo
    i = 'Bom dia!'
    print(i)
print("-" * 180)
y = 0 # contador
while y <= 4: # condição
    print("Bom dia!")
    y = y + 1 # passo

"""Contagem de um determinado número inicial até o número final."""

inicial = int(input("Comece digitando o 1º número: "))
final = int(input("Digite o 2º número: "))
i = inicial
while i <= final:
    print(i)
    i += 1

"""Código clássico de iteração usando acumuladores - somar vários valores dentro de uma variável, isto é, acumular: Copie o código acima e refaça-o utilizando variável acumuladora somando os valores entre dois números digitados pelo usuário:"""

inicial = int(input("Comece digitando o 1º número: "))
final = int(input("Digite o 2º número: "))
i = inicial
soma = 0 # variável acumuladora
while i <= final:
    print(i)
    soma += i
    i += 1
print("Resultado da soma: ",soma)

"""Código decremental - contagem regressiva"""

i = 10
while i >= 1:
    print("Contagem", i)
    i = i - 1

"""Imprima, utilzando o laço while, todos os valores múltiplos de 5 num intervalo de 0 a 100:"""

i = 0
while i <=100:
    if (i % 5 == 0):
        print(f"{i} é múltiplo de 5.")
    i += 1

#Validando numero positivo com laço while
num = int(input("Digite um número positivo: "))
while num <= 0:
    num = int(input("Inválido! Digite apenas número positivo: "))

print("Enfim número positivo.")

"""Comando for:"""

ListaAluno = ['Mario', 'Luigi', 'Yoshi']
for aluno in ListaAluno:
    print(f"Bem vindo {aluno}!")

for i in range(1,55,3):
    print(i)

#Decremental com for
for i in range(10,0,-1):
    print(i)

"""Exercício estruturas de repetição: Faça um programa que descubra qual a soma dos primeiros 50 números. Depois some somente numeros ímpares."""

soma = 0
i = 1
while i <= 50:
    soma += i
    i += 1
print(f"A soma dos valores é: {soma}")
print("-" * 180)
# Segunda parte do exercício:
soma = 0
i = 1
while i <= 50:
    soma = soma + i
    i += 2
print(f"A soma dos ímpares é: {soma}")
print("-" * 180)
# Outra solução implementando if
i = 1
soma = 0
while i <= 50:
    if i % 2 != 0:
        soma = soma + i
    i = i + 1
print(f"A soma contendo o desvio condicional 'if', em relação aos valores ímpares é: {soma}")

"""Exercício 2 - Faça um programa que peça a um usuário que digite seu nome e um número inteiro, imprima o nome daquele usuário o número de vezes relativo ao número digitado."""

#Exercício com laço while
nome = input("Digite o seu nome: ")
num = int(input("Digite o número de vezes que seu nome será repetido: "))
y= 1
while y <= num:
    print(nome)
    y = y + 1
print("-" * 180)
# Exercício com laço for
nome = input("Digite o seu nome: ")
num = int(input("Digite o número de vezes que seu nome será repetido: "))
for i in range(num):
    print(nome)
print("-" * 180)
#Exercício sem laços de repetição
nome = input("Digite o seu nome: ")
num = int(input("Digite o número de vezes que seu nome será repetido: "))
print((nome+"\n") * num)

"""Exercício 3 - Modulo 3 - Leônidas é constantemente questionado sobre quantos soldados seus trezentos espartanos irão enfrentar. Ajude Leônidas fazendo um pequeno jogo de advinhação em que o jogador deve dar um palpite. Caso seja abaixo ou acima do valor correto, imprima mensagens adequadas informando o fato. (Valor correto deve ser 10000)"""

palpite = int(input("Digite seu palpite acerca de quantos soldados o exército de Leônidas enfrentará: "))
while palpite != 10000:
    print("Errado! Tente novamente.")
    palpite = int(input("Digite seu palpite acerca de quantos soldados o exército de Leônidas enfrentará: "))
print("Parabéns!Você acertou!")

#Igual ao exercício acima, porém brincando com o modulo randômico
import random
soldados = random.randint(0, 10000)
print(soldados)
while palpite != soldados:
    palpite = int(input("Digite seu palpite acerca de quantos soldados o exército de Leônidas enfrentará. Caso queira sair, digite o número 0. "))
    if palpite == 0:
        print(f"Você digitou {palpite}. Encerrando!")
        break
    elif palpite == soldados:
        print("Parabéns, você acertou!")
        break
    elif palpite != soldados:
        print("Errado. Tente novamente.")

"""Faça um programa que leia valores do teclado até o usuário digitar zero. Porém, no momento em que o usuário digitar zero, o programa deve mostrar qual foi o maior valor digitado:"""

valor = int(input("Digite um valor: "))
maximo = valor
while valor:
    valor = int(input("Digite um valor: "))
    if valor > maximo:
        maximo = valor
    valor = int(input("Digite um valor: "))
print("Valor máximo: {}".format(maximo))

"""Faça um programa que repetidamente pergunte a idade e o gênero para o usuário. E para cada resposta o programa deve responder imprimindo a mensagem:
"Boa noite rapaz." Caso genêro masculino e idade < 18
"Boa noite senhor." caso genero masculino e idade >= 18
"Boa noite moça." caso gênero feminino e idade < 18
"Boa noite senhora." caso gênero feminino e idade >= 18
quando o usuário digitar zero no campo de idade, encerre o programa.
"""

idade = int(input("Qual a sua idade? "))
if idade == 0:
    print("Encerrando...")
while idade != 0:
    genero = input("Qual o seu gênero? ").lower()
    if idade < 18 and genero == 'masculino':
        print("Boa noite rapaz!")
    elif idade > 18 and genero == 'masculino':
        print("Boa noite senhor!")
    elif idade < 18 and genero == 'feminino':
        print("Boa noite moça!")
    elif idade >= 18 and genero == 'feminino':
        print("Boa noite senhora!")
    idade = int(input("Qual a sua idade? "))
    if idade == 0:
        print("Encerrando...")

"""Faça um código que imprima os números de 1 até 50 em ordem crescente e depois em oredem decrescente. Seu código deve pular o número 37."""

#Decrescente
for i in range(50, 0, -1):
    if i == 37:
        continue
    print(i)
print("-" * 180)
#Crescente
for i in range(0, 51, 1):
    if i == 37:
        continue
    print(i)

"""Faça um programa que imprima a tabuada do 1 ao 10:"""

for i in range(1, 11):
    for j in range(1, 11):
        print("{} x {} = {}".format(i, j, i * j))

# com 2 while
tabuada = 1
while tabuada <= 10:
  print('Tabuada do {}'.format(tabuada)) #laço externo
  i = 1
  while i <= 10: #Laço interno
    print('{} x {} = {}'.format(tabuada, i, tabuada * i))
    i += 1 # variável iteradora do 2 while - variável iteradora do laço externo
  tabuada += 1 # variável iteradora do 1 while - variável iteradora do laço interno

mylist = [1,2,3]
for v in range(len(mylist)):
    mylist.insert(1, mylist[v])
print(mylist)

"""Laços de repetição, curso Python Impressionador Módulo 6:

Imagine que você está construindo uma automação para enviar todo dia por e-mail, um resumo da produção de uma fábrica. Construa um código que exiba a quantidade produzida produto nesse e-mail.
"""

produtos = ['coca', 'pepsi', 'guarana', 'sprite', 'fanta']
produção = [1500, 12000, 13000, 5000, 250]
tamanho_produtos = len(produtos)
for i in range(tamanho_produtos):
    print('{} unidades produzidas de {}.'.format(produção[i], produtos[i]))

#Forma mais simples
produtos = ['coca', 'pepsi', 'guarana', 'sprite', 'fanta']
for produto in produtos:
    print(produto)
texto = 'vitor@gmail.com'
for ch in texto:
    print(ch, end=" ")

"""Digamos que estamos analisando a meta de venda de vários funcionários de uma empresa. A meta de vendas é de 1000 reais em 1 dia. Temos uma lista com as vendas de todos os funcionários e quero calcular qual o % de pessoas bateram a meta."""

#Combinar o for com if
vendas = [1200, 300, 800, 1500, 1900, 2750, 400, 20, 23, 70, 90, 80, 1100, 999, 900, 880, 870, 50, 1111, 120, 300, 450, 800]
meta = 1000
#contador abaixo
qtde_bateu_meta = 0
for venda in vendas:
    if venda >= 1000:
        qtde_bateu_meta += 1

print(f"{qtde_bateu_meta} pessoas bateram a meta.")
#Para saber a quantidade de pessoas da lista
qtd_funcionarios = len(vendas)
print("O percentual de pessoas que bateram a meta foi de {:.0%}.".format(qtde_bateu_meta / qtd_funcionarios))

"""Uso do enumerate, usado melhor quando precisa de um índice da lista. O enumerate permite que você percorra uma lista e ao mesmo tempo tenha em uma variável o índice daquele item."""

#Entendendo o enumerate
funcionarios = [ 'Maria', 'José', 'Antonio', 'João', 'Francisco', 'Ana', 'Luiz', 'Paulo', 'Carlos', 'Manoel', 'Pedro', 'Francisca', 'Marcos', 'Raimundo', 'Sebastião', 'Antônia', 'Marcelo', 'Jorge', 'Márcia', 'Geraldo', 'Adriana', 'Sandra', 'Luis']
for i, funcionarios in enumerate(funcionarios):
    print('O índice {} corresponde ao(a) funcionário(a) {}'.format(i, funcionarios))

"""Exemplo Prático de mínimo de estoque. Em uma fábrica você tem vários produtos e não pode deixar que os produtos fiquem em falta. Para isso, foi definido uma quantidade mínima de estoque que os produtos precisam ter. Identifique, portanto, quais produtos estão abaixo do nível mínimo de estoque."""

estoque = [1200, 300, 800, 1500, 1900, 2750, 400, 20, 23, 70, 90, 80, 1100, 999, 900, 880, 870, 1111, 120, 300, 450, 800]
produtos = ['Coca', 'Pepsi', 'Guarana', 'Skol', 'Brahma', 'Água', 'Del Valle', 'Dolly', 'Red Bull', 'Cachaça', 'Vinho Tinto', 'Vodka', 'Tequila', 'Champagne']
nivel_minimo = 50
for i, qtd in enumerate(estoque):
    if qtd < nivel_minimo:
        print("O produto {} está abaixo do nível mínimo. Temos apenas {} unidades.".format(produtos[i], qtd))

"""Exercício - Criando um registro de hóspede. Digamos que você está criando um regitro de hóspedes em um hotel. No hotel, os hóspedes podem ter quartos com 1, 2, 3 e 4 pessoas. Seu sistema deve conseguir:
1 - Identificar quantas pessoas o hóspede que acabou de chegar vai ter no quarto (perguntando por meio de input).
2 - De acordo com a quantidade de pessoas, fazer um for para perguntar cpf e o nome de cada pessoa, a fim de registrá-la no quarto. (2 inputs para cada pessoa, 1 para o cpf e outro para o nome)
3 - O seu programa então deve gerar uma lista com todas as pessoas que ficarão no quarto em que cada item dessa lista é o nome da pessoa e o cpf da pessoa, assim:
['Joao', 'cpf:000000000']...

"""

qtd_pessoas = int(input("Digite quantas pessoas irão se hospedar no quarto: ")) # Registro de quantas pessoas irão se hospedar no quarto
quarto = [] # Lista vazia que será preenchida com nome e cpf
for i in range(qtd_pessoas): # laço de repetição
    nome = input("Digite o nome: ") # variavel que registra nome
    cpf = int(input("Digite o cpf: ")) # variável que regista o cpf
    hospede = ["Nome: {}. CPF: {}.".format(nome, cpf)] # lista que receberá os nomes e os cpfs
    quarto.append(hospede) # comando append para colocar dentro da até então lista vazia "quartos[]" a lista hospede(nomes e cpfs)
print(quarto) # print dos nomes e cpfs

"""Análise de Vendas -
Exercício simples sobre atingir. Temos uma lista com os vendedores e os valores de vendas e queremos identificar (printar) quais os vendedores que bateram a meta e qual foi o valor que ele(s) venderam.
"""

meta = 10000
vendas = [
    ['joão', 15000],
    ['Julia', 27000],
    ['Marcus', 9900],
    ['Maria', 3750],
    ['Ana', 10300],
    ['Alon', 7870],
]
#Codigo abaixo
for i in vendas:
    if i[1] >= meta:
        print(f"Vendedor {i[0]} bateu a meta fazendo {i[1]} vendas.")

"""Exercício 3 - Comparação do ano anterior - Digamos que você está analisando as vendas de produtos de um ecommerce e quer identificar quais produtos tiveram no ano de 2020 mais vendas do que no ano de 2019, cuja finalidade é reportar à diretoria. Sua resposta deve ser um print de cada produto, qual foi a venda de 2019, a venda de 2020 e o % de crescimento de 2020 para 2019. Lembrando que para calcular a porcentagem de crescimento de um produto de um ano para o outro, pode-se utilizar(vendas_produto2020/vendas_produto2019-1)
Dica: lembre do enumerate, pois pode facilitar o laço for.
"""

produtos = ['Iphone', 'Galaxy', 'Ipad', 'Tv', 'Maquina de Cafe', 'kindle', 'Geladeira','Adega', 'Notebook Dell']
vendas2019 = [558147, 712350, 573823, 405252, 718654, 531580, 973139, 892292, 422760]
vendas2020 = [951642, 244295, 26964, 787604, 867660, 78830, 710331, 646016, 694916]
#codigo aqui

for i, produto in enumerate(produtos):
    crescimento = vendas2020[i] / vendas2019[i] - 1
    if vendas2020[i] > vendas2019[i]:
        print("{} vendeu R$ {:,} em 2019, R$ {:,} em 2020 e teve {:.1%} de crescimento.".format(produto, vendas2019[i], vendas2020[i], crescimento))

"""For dentro de For - quando temos listas dentro de listas, às vezes precisamos fazer um 'for dentro de for'. Vamos pegar um exemplo de nível de estoque. Em uma fábrica você tem vários produtos que ficam em falta. Para tal, foi definido uma quantidade mínima de estoque que os produtos precisam ter:
Identifique quais fábricas tem algum produto abaixo do nível de estoque. Agora, em vez de analisar o estoque de apenas uma fábrica, vamos analisar o estoque de várias fábricas. Observe que o indíce zero da lista estoque (por sinal é uma outra lista) corresponde aos dados inerentes ao índice zero da lista fábricas, isto é, vitor manufactoring, e assim por diante.

EXTEND - LISTA - 1 parâmetro obrigatório
"""

vendedores = ['João', 'Julia', 'Ana', 'José', 'Maria', 'Paulo', 'Rodrigo']
vendedores_adicionais = ['Paco', 'Trujillo']
vendedores.extend(vendedores_adicionais)
print(vendedores)

#Sempre pesnar o código como se fosse top down, do macro para o micro
estoque = [
    [294, 125, 269, 208, 783, 852, 259, 47, 102, 386, 87, 685, 697, 941, 163, 631, 7, 714, 218, 670, 453],
    [648, 816, 310, 555, 992, 643, 226, 319, 501, 23, 239, 42, 372, 441, 126, 645, 927, 911, 761, 445, 974, 2, 549],
    [832, 683, 784, 449, 977, 705, 198, 937, 729, 327, 339, 10, 975, 310, 95, 689, 137, 795, 211, 538, 933, 751, 522],
    [837, 168, 570, 397, 53, 297, 966, 714, 72, 737, 259, 629, 625, 469, 922, 305, 782, 243, 841, 848, 372, 621, 362],
    [429, 242, 53, 985, 406, 186, 198, 50, 501, 870, 781, 632, 781, 105, 644, 509, 401, 88, 961, 765, 422, 340, 654],
]
fabricas = ['Vitor manufactoring', 'Fábrica CCR-Cover-Brasil', 'Python Manufaturas', 'Produções e cia', 'Manufatura e cia']
nivel_minimo = 50
fabricas_abaixo_nivel = [] #Lista vazia para adicionar as fabricas que estão abaixo do nivel de estoque
#Codigo abaixo
for i, lista in enumerate(estoque): #Esse laço externo confere as listas.
    for qtd in lista: #Este laço interno confere os elementos dentro das listas
        if qtd < nivel_minimo: #analisa condição da quantidade expressa na variável (nivel_minimo) cujo valor é 50.
            if fabricas[i] in fabricas_abaixo_nivel: #Confere item dentro da nova lista para que ele não seja duplicado
                pass
            else:
                fabricas_abaixo_nivel.append(fabricas[i]) #Adiciona os elementos da condição na lista vazia
print(fabricas_abaixo_nivel)

"""Exercício - Calculando o percentual de uma lista. Será algo parecido com "filtrar" uma lista. Mais para frente aprenderemos outras maneiras de fazer isso. Tem-se uma lista de vendedores e em vez de saber todos os vendedores que bateram a meta, eu quero connseguir calcular o % de vendedores que bateram a meta. Ou seja, se temos 10 vendedores e 3 bateram a meta, 30% bateu a meta."""

#Resolução
meta = 10000
vendas = [
    ['João', 15000],
    ['Julia', 27000],
    ['Marcus', 9900],
    ['Maria', 3750],
    ['Ana', 10300],
    ['Alon', 7870],
]
#Criando lista auxiliar vazia para resolver o problema
acima_meta = []

for venda in vendas:
    if venda[1] >= meta:
        acima_meta.append(venda) #Adiciona na lista vazia aqueles(as) que bateram a meta.
#Varialvel para o calculo percentual
porcentagem = len(acima_meta) / len(vendas)
print("{:.0%} dos vendedores bateram a meta.".format(porcentagem))

#Resolução Alternativa
meta = 10000
vendas = [
    ['João', 15000],
    ['Julia', 27000],
    ['Marcus', 9900],
    ['Maria', 3750],
    ['Ana', 10300],
    ['Alon', 7870],
]
qtd_vendedores_acima = 0 #Variavel contadora para somar vendedores acima da meta
for venda in vendas:
    if venda[1] >= meta:
        qtd_vendedores_acima += 1
print("{:.0%} dos vendedores bateram a meta.".format(qtd_vendedores_acima / len(vendas)))

"""Crie uma estrutura parecida para imprimir quem foi o vendedor que mais vendeu."""

vendas = [
    ['João', 15000],
    ['Julia', 27000],
    ['Marcus', 9900],
    ['Maria', 3750],
    ['Ana', 10300],
    ['Alon', 7870],
]
maior_venda = 0
melhor_vendedor = ""
for vendedor in vendas:
    if vendedor[1] > maior_venda:
        maior_venda = vendedor[1]
        melhor_vendedor = vendedor[0]
print(f"A venda foi no valor de R${maior_venda}.")
print(f"O(a) vendedor(a) responsável pela venda foi: {melhor_vendedor}.")

"""Formas de interromper um For - Break = interrompe e finaliza. Continue = interrompe e vai para o próximo item do for"""

vendas = [100, 150, 1500, 2000, 120]
#se todas as vendas forem acima da meta, a loja ganha bônus
meta = 110
for venda in vendas:
    if venda < meta:
        print("A loja não ganha bônus!")
        break # Como encontrou a condição, o break finaliza o código e imprime somente o print "A loja não ganha bônus"
    print(venda)

"""Exemplo de continue:"""

#Exiba quem bateu a meta
vendas = [100, 150, 1500, 2000, 120]
vendedores = ['João', 'Julia', 'Ana', 'José', 'Maria']
meta = 130
for venda in vendas:
    if venda < meta:
        continue
    print(venda)

"""Estrutura While - Python Impressionador - Crie um programa que funcione como registro de vendas de uma empresa. Nele, a pessoa deve inserir o nome do produto e este deve ser adicionado à lista de venda. Enquanto o usuário não encerrar o programa, significa que em tese está registrando novos produtos. Assim sendo, o programa deve permitir a entrada de quantos produtos o usuário quiser."""

vendas = []
#Crie o programa a partir daqui
while True:
    venda = input("Registre um produto. Para cancelar o registro de um novo produto, basta apertar enter com a caixa vazia. ")
    if venda == '':
        print("Encerrando!")
        break
    else:
        vendas.append(venda)
print("Foram registrado(s) o(s) produto(s): {}".format(vendas))

venda = input("Registre um produto. Para cancelar o registro de um novo produto, basta apertar enter com a caixa vazia. ")
vendas = []
while venda != '':
    vendas.append(venda)
    venda = input("Registre um produto. Para cancelar o registro de um novo produto, basta apertar enter com a caixa vazia. ")
print(vendas)

"""Exercício para treinar a lógica do while. 1 - Crie um sistema de vendas, registrando os produtos e as quantidades (2 inputs) adicionando-os à uma lista. O programa deve continuar até o input ser vazio, isto é, o usuário apertar enter em uma caixa vazia.
Ao final do programa, ele deve printar todos os produtos e quantidades vendidas. Obs: caso queira um print mais visual, pode usar o join para cada item ser printado em uma linha. A sugestão para a lista de produtosvendidos estárá abaixo no código.

"""

vendas = []
while True:
    produto = input("Qual produto deseja: ")
    if not produto: #se não preencher o produto e digitar enter em caixa vazia, o loop para
        break
    qtd = int(input("Qual quantidade deseja comprar: "))
    vendas.append([produto, qtd])

print(vendas)

"""Curso Python Impressionador - Tuplas"""

vendas = ('Vitor', '25/11/2022', '09/11/1982', 2000, 'Estagiário')
print(vendas)
nome = vendas[0]
data_contratacao = vendas[1]
data_mascimento = vendas[2]
salario = vendas[3]
cargo = vendas[4]

"""Forma mais simples de fazer o que está acima:"""

#unpacking tupla
vendas = ('Vitor', '25/11/2022', '09/11/1982', 2000, 'Estagiário')
nome, data_contratacao, data_mascimento, salario, cargo = vendas
print(nome)

"""O comando enumerate cria uma Tupla. Exemplo no código abaixo:"""

vendas = [1000, 2000, 300, 300, 150]
funcionarios = ['João', 'Lira', 'Ana', 'Maria', 'Paula']

for i, venda in enumerate(vendas):
    print('{} vendeu {} unidades.'.format(funcionarios[i], venda))

"""Exemplo de análise de um banco de dados de um e-commerce:"""

vendas = [
    ('20/08/2020', 'iphone x', 'azul', '128gb', 350, 4000),
    ('20/08/2020', 'iphone x', 'prata', '128gb', 1500, 4000),
    ('20/08/2020', 'ipad', 'prata', '256gb', 127, 6000),
    ('20/08/2020', 'ipad', 'prata', '128gb', 981, 5000),
    ('21/08/2020', 'iphone x', 'azul', '128gb', 397, 4000),
    ('21/08/2020', 'iphone x', 'prata', '128gb', 1017, 4000),
    ('21/08/2020', 'ipad', 'prata', '256gb', 50, 6000),
    ('21/08/2020', 'ipad', 'prata', '128gb', 4000, 5000),
]
#Qual foi o faturamento do Iphone no dia 20/08/2020?


faturamento = 0
for item in vendas: # para cada item da lista, que é uma tupla, precisamos desmembrar as informações
    data, produto, cor, capacidade, unidades, valor_unitario = item # processo de unpacking da tupla recebendo o "item"
    if produto == 'iphone x' and data == '20/08/2020':
        faturamento += unidades * valor_unitario
print(f" O faturamento de Iphone no dia 20/08/2020 foi de: {faturamento}.")

#Qual foi o produto mais vendido (em unidades) no dia 21/08/2020?
vendas = [
    ('20/08/2020', 'iphone x', 'azul', '128gb', 350, 4000),
    ('20/08/2020', 'iphone x', 'prata', '128gb', 1500, 4000),
    ('20/08/2020', 'ipad', 'prata', '256gb', 127, 6000),
    ('20/08/2020', 'ipad', 'prata', '128gb', 981, 5000),
    ('21/08/2020', 'iphone x', 'azul', '128gb', 397, 4000),
    ('21/08/2020', 'iphone x', 'prata', '128gb', 1017, 4000),
    ('21/08/2020', 'ipad', 'prata', '256gb', 50, 6000),
    ('21/08/2020', 'ipad', 'prata', '128gb', 4000, 5000),
]
# é preciso criar duas variáveis auxiliares, uma para armazenar o produto mais vendido e outra para armazenar a quantidade mais vendida
produto_mais_vendido = ''
qtd_produto_mais_vendido = 0
for item in vendas:
    data, produto, cor, capacidade, unidades, valor_unitario = item
    if data == '21/08/2020':
        if unidades > qtd_produto_mais_vendido:
            produto_mais_vendido = produto
            qtd_produto_mais_vendido = unidades
print(f"O produto mais vendido no dia 21/08/2020 foi o {produto_mais_vendido} com {qtd_produto_mais_vendido} unidades vendidas.")

"""Exercício de unpacking tuplas. Análise sobre atingir meta - Há uma lista com vendedores e valores de vendas, sendo que nosso intuito é identificar (printar) quais vendedores bateram a meta e qual valor venderam."""

meta = 10000
vendas = [
    ('João', 15000),
    ('Julia', 27000),
    ('Marcus', 9900),
    ('Maria', 3750),
    ('Ana', 10300),
    ('Alon', 7870),
]
for vendedor, valor_venda in vendas:
    if valor_venda >= meta:
        print("{} bateu a meta vendendo {}.".format(vendedor, valor_venda))

"""Exercício 2 - Comparação do ano anterior - Digamos que você está analisando as vendas de produtos de um ecommerce e quer identificar quais produtos tiveram no ano de 2020 mais vendas do que no ano de 2019, cuja finalidade é reportar à diretoria. Sua resposta deve ser um print de cada produto, qual foi a venda de 2019, a venda de 2020 e o % de crescimento de 2020 para 2019. Lembrando que para calcular a porcentagem de crescimento de um produto de um ano para o outro, pode-se utilizar(vendas_produto2020/vendas_produto2019-1)."""

vendas_produtos = [('Iphone', 558147, 951642), ('Galaxy', 712350, 244295), ('Ipad', 573823, 26964), ('Tv', 405252, 406325 ), ('Maquina de Cafe', 332569, 553256 ), ('kindle', 222569, 332114 ), ('Geladeira', 222547, 112256), ('Adega', 332598, 224563), ('Notebook Dell', 225563, 224569)]
for produto, vendas2019, vendas2020 in vendas_produtos:
    if vendas2020 > vendas2019:
        print("O produto {} vendeu {} em 2019 e {} em 2020. Crescimento de {:.1%}.".format(produto, vendas2019, vendas2020, vendas2020 / vendas2019 - 1))

"""2

Python Impressionador - Dicionários = {chave: valor, chave: valor, chave: valor}
Vantagens e desvantagens: Não devem ser usados para pegar itens em uma determinada ordem. Podem ter valores heterogêneos(vários tipos de valores dentro de um mesmo dicionário: inteiros, strings, listas, etc). Chaves são unicamente obrigatórias. Mais intuitivo de trabalhar.
"""

# exemplo de dicionário
mais_vendidos = {'tecnologia': 'Iphone', 'Refrigeração': 'Ar Cônsul 12000 btu', 'Livros': 'O Alquimista', 'Eletrodoméstico': 'Geladeira', 'Lazer': 'prancha surf'}
vendas_tecnologia = {'Iphone': 15000, 'Samsung galaxy': 12000, 'Tv Samsung': 10000, 'Ps5': 14300, 'Tablet': 1720, 'Ipad': 1000, 'Tv Philco': 2500, 'Laptop Hp': 1000, 'Laptop Dell': 17000,  'Azus': 24500}
# Qual foi o item mais vendido nas categorias 'livros' e 'Lazer'?
# Quanto foi vendido na categoria azus e Ipad?
livro = mais_vendidos['Livros']
lazer = mais_vendidos['Lazer']
ipad = vendas_tecnologia['Ipad']
azus = vendas_tecnologia['Azus']
print(f"O livro mais vendido foi '{livro}' e na categoria lazer foi '{lazer}'.")
print(f"Vendeu {ipad} Ipads.")
print(f"Vendeu {azus} Azus.")

"""Respondendo as mesmas questões acima com o método get."""

mais_vendidos = {'tecnologia': 'Iphone', 'Refrigeração': 'Ar Cônsul 12000 btu', 'Livros': 'O Alquimista', 'Eletrodoméstico': 'Geladeira', 'Lazer': 'prancha surf'}
vendas_tecnologia = {'Iphone': 15000, 'Samsung galaxy': 12000, 'Tv Samsung': 10000, 'Ps5': 14300, 'Tablet': 1720, 'Ipad': 1000, 'Tv Philco': 2500, 'Laptop Hp': 1000, 'Laptop Dell': 17000,  'Azus': 24500}
print(f"Vendeu {vendas_tecnologia.get('Azus')} azus.")
print(f"O livro mais vendido foi '{mais_vendidos.get('Livros')}' e na categoria lazer foi '{mais_vendidos.get('Lazer')}'.")
print(f"Vendeu {vendas_tecnologia.get('Ipad')} Ipads.")

"""Verificando itens no dicionário. Usa-se o if e a função .get(chave) = None

"""

copos = 'copos'
vendas_tecnologia = {'Iphone': 15000, 'Samsung galaxy': 12000, 'Tv Samsung': 10000, 'Ps5': 14300, 'Tablet': 1720, 'Ipad': 1000, 'Tv Philco': 2500, 'Laptop Hp': 1000, 'Laptop Dell': 17000,  'Azus': 24500}
#Formas de verificação de intens dentro de dicionários
if 'copos' in vendas_tecnologia:
    print(v)
else:
    print("Não existe este item no dicionário.")
print(vendas_tecnologia.get('copos'))
print("*" * 180)
#Outra forma de verificação:
if vendas_tecnologia.get('copos') == None:
    print("A chave requisitada não existe!")

"""ADICIONAR, REMOVER E MODIFICAR ITENS EM DICIONÁRIOS:"""

#Estrutura para adicionar itens:
#dicionario = {}
#dicionario[chave] = valor
#outra opção
#dicionario.update({chave: valor, chave: valor})

lucro_1tri = {'Janeiro': 100000, 'Fevereiro': 120000, 'Março': 90000}
lucro_2tri = {'Abril': 88000, 'Maio': 89000, 'Junho': 120000}
#adicionando item:
lucro_1tri['Abril'] = 8800
print(lucro_1tri)
print("*" * 180)
#Adicionando vários itens ou um dicionário a outro:
lucro_1tri.update(lucro_2tri)
print(lucro_1tri)
print("*" * 180)
#Outra forma cujo resultado é o mesmo do resultado acima:
lucro_1tri.update({'Abril': 88000, 'Maio': 89000, 'Junho': 120000})
print(lucro_1tri)
#Caso queira adicionar um valor cuja chave já existe, este valor será atualizado pelo novo valor. Obs: não pode existir 2 chaves iguais no dicionário

"""REMOVER ITENS DO DICIONÁRIO:

"""

#deletar com del - também funciona para lista:
lucro_1tri = {'Janeiro': 100000, 'Fevereiro': 120000, 'Março': 90000}
lucro_2tri = {'Abril': 88000, 'Maio': 89000, 'Junho': 120000}
del lucro_2tri['Junho']
print(lucro_1tri)
print("*" * 180)
#deletar com pop.(chave) - retira o item e o armazena em uma variável para caso queira usa-lo posteriormente
Janeiro = lucro_1tri.pop('Janeiro')
print(lucro_1tri)
print("*" * 180)

"""Estrutura For nos dicionários:"""

vendas_tecnologia = {'Iphone': 15000, 'Samsung galaxy': 12000, 'Tv Samsung': 10000, 'Ps5': 14300, 'Tablet': 1720, 'Ipad': 1000, 'Tv Philco': 2500, 'Laptop Hp': 1000, 'Laptop Dell': 17000,  'Laptop Asus': 24500}
for key in vendas_tecnologia:
    print(key, vendas_tecnologia[key])

#Localizar elemento no dicionário
vendas_tecnologia = {'Iphone': 15000, 'Samsung galaxy': 12000, 'Tv Samsung': 10000, 'Ps5': 14300, 'Tablet': 1720, 'Ipad': 1000, 'Tv Philco': 2500, 'Laptop Hp': 1000, 'Laptop Dell': 17000,  'Laptop Asus': 24500}
total_laptop = 0
for key in vendas_tecnologia:
    if 'Laptop' in key:
        total_laptop +=  vendas_tecnologia[key]
print(f"O total de laptops vendidos é: {total_laptop}")

"""PYTHON IMPRESSIONADOR - EXERCÍCIOS - DICIONÁRIOS:

Identificando locais de risco. Digamos que o programa precisa identificar os níveis de Co2, em determinados locais a fim de evitar potenciais acidentes. Em cada um desses locais a sua empresa tem 5 sensores que captam o nível de CO2 do local. Os níveis normais de CO2 são em média 350. O nível de CO2 de um local é dado pela média captada pelos 5 sensores. Isso significa que se tivermos 5 sensores no Rio de Janeiro marcando: 350, 400, 450, 350, 300, o nível de CO2 do RJ será dado por (350, 400, 450, 350, 300 / 5 = 370). Caso o nível seja maior que 450, um aviso deve ser exibido pelo programa dizendo, p. ex: RJ está com níveis altíssimos de CO2(490), chamar equipe especializada para verificar  a região. Os resultados dos sensores  são monitorados frequentemente e são dados para o sistema em forma de dicionário.
"""

niveis_CO2 = {
    'AC': [325, 405, 429, 486, 402],
    'AL': [492, 495, 310, 407, 388],
    'AM': [507, 503, 368, 338, 400],
    'BA': [321, 508, 372, 490, 412],
    'CE': [424, 328, 425, 516, 480],
    'ES': [449, 506, 461, 337, 336],
    'GO': [425, 460, 385, 485, 460],
    'MA': [361, 310, 344, 425, 490],
    'MT': [358, 402, 425, 386, 379],
    'MS': [324, 357, 441, 405, 427],
    'MG': [345, 367, 391, 427, 516],
    'PA': [479, 514, 392, 493, 329],
    'PB': [418, 499, 317, 302, 476],
    'PR': [420, 508, 419, 396, 327],
    'PE': [404, 444, 495, 320, 343],
    'PI': [513, 513, 304, 377, 475],
    'RJ': [502, 481, 492, 502, 506],
    'RN': [446, 437, 519, 356, 317],
    'RS': [427, 518, 459, 317, 321],
    'RO': [517, 466, 512, 326, 458],
    'RR': [466, 495, 469, 495, 310],
    'SC': [495, 436, 382, 483, 479],
    'SP': [495, 407, 362, 389, 317],
    'SE': [508, 351, 334, 389, 418],
    'TO': [339, 490, 304, 488, 419],
    'DF': [376, 516, 320, 310, 518],
}

for estado in niveis_CO2:
    qtd_sensores = len(niveis_CO2[estado])
    total_CO2 = sum(niveis_CO2[estado])
    media_CO2 = total_CO2 / qtd_sensores
    if media_CO2 > 450:
        print(f"{estado} está com níveis altíssimos de CO2({media_CO2}). Chamar equipe especializada para verificar a região.")

"""2 - CASE DA HASHTAG - Recentemente tivemos que fazer backups dos vídeos que temos hospedados no Vimeo. Acontece que não existe um botão de download de todos os vídeos ao mesmo tempo e precisamos entrar 1 por 1 para fazer o download manualmente. A alternativa, no entanto, é gerar um código Python que converse com a API do Vimeo (API é uma integração que as ferramentas abrem para programadores poderem fazer integrações dos seus próprios programas/scripts com a ferramenta). Para resolver isso, fez-se uma integração e uma 'requisição' de todos os vídeos para a Vimeo. Tal requisição retorna para o nosso código o que segue abaixo:"""

#O dicionário original é muito maior e muito mais confuso, mas para fins didáticos e para facilitar a cópia manual, me ative somente ao ponto fulcral do exercício
video = {'uri': '/videos/465407533', 'name': '15 Atalhos no Excel para Ficar Mais Produtivo', 'download': [{'quality': 'source', 'expires': '20-10-07T04:00:55+00:00', 'link': 'http://player.vimeo.com/play/2064518513?s=465407_1602043255_5f2f9dd00b66eba66d481f913383b4f&loc=externa&context=Vimeo%5CController%5CApi%5CResources%5CUser%5CvideosController.&download=1&filename=15%2BAtalhos%2Bno%2BExcel%2BProdutivosource.mp4'}]}
print(video)
#É um código confuso, mas é um dicionário
#Se pegar a chave link e colar no navegador, faria o download. Neste caso não fará porque a "expire date" expirou 'expires'.
#Construir o código que vai pegar o 'link':
for item in video:
    print(item)
# Afunilando a procura do link para download
print(video['download'][0]['link'])

"""MÉTODOS PRONTOS E ÚTEIS PARA DICIONÁRIOS - ITEMS() DOS DICIONÁRIOS."""

#ESTRUTURA = items_dicionario = dicionario.items(). Ou então:
#for item in dicionario.items()
#   cada item do dicionario em formato de tupla
vendas_tecnologia = {'Iphone': 15000, 'Samsung galaxy': 12000, 'Tv Samsung': 10000, 'Ps5': 14300, 'Tablet': 1720, 'Ipad': 1000, 'Tv Philco': 2500, 'Laptop Hp': 1000, 'Laptop Dell': 17000,  'Laptop Asus': 24500}

#items_dicionario = dicionario.items() - Tranforma o dicionário em uma lista de tuplas, cujo 1º item é a chave e o 2º é o valor
itens_dicionario = vendas_tecnologia.items()
print(itens_dicionario)
print('-' * 180)
#for item in dicionario.items()
for item in vendas_tecnologia.items():
    print(item)
print("-" * 180)
#Outra forma de acesso
for produto, qtd in vendas_tecnologia.items():
    print("{}: {} unidades.".format(produto, qtd))

"""Quais produtos venderam mais de 5000 unidades?"""

vendas_tecnologia = {'Iphone': 15000, 'Samsung galaxy': 12000, 'Tv Samsung': 10000, 'Ps5': 14300, 'Tablet': 1720, 'Ipad': 1000, 'Tv Philco': 2500, 'Laptop Hp': 1000, 'Laptop Dell': 17000,  'Laptop Asus': 24500}
for chave in vendas_tecnologia:
    if vendas_tecnologia[chave] > 5000:
        print("{}: {} unidades.".format(chave, vendas_tecnologia[chave]))
print('-' * 180)
#Outra forma usando o dicionário.items()
for produto, qtd in vendas_tecnologia.items():
    if qtd > 5000:
        print(f"{produto}: {qtd} unidades.")

"""LISTAS IMPORTANTES A PARTIR DOS DICIONÁRIOS - MÉTODOS IMPORTANTES

"""

#método keys() - uma "lista" com todas as chaves do dicionário
#values() - uma "Lista" com todos os valores do dicionário
#Obs - se o dicionário for modificado, automaticamente essas variáveis são modificadas, mesmo tendo sido criadas anteriormente
vendas_tecnologia = {'Iphone': 15000, 'Samsung galaxy': 12000, 'Tv Samsung': 10000, 'Ps5': 14300, 'Tablet': 1720, 'Ipad': 1000, 'Tv Philco': 2500, 'Laptop Hp': 1000, 'Laptop Dell': 17000,  'Laptop Asus': 24500}
chaves = vendas_tecnologia.keys()
valores = vendas_tecnologia.values()
vendas_tecnologia['Vitor Phone'] = 10
print((vendas_tecnologia))
print("-" * 210)
print(chaves) #Qualquer modificação em chaves e valores serão parte do dicionário
print(valores)
print("-" * 210)

"""O for funciona normalmente em dict_listas, haja vista que não deixa de ser uma lista de itens para se percorrida (iterable), mas o que aprendemos de lista não necessariamente se aplica a essas dict_listas. Por isso, para transformar as dict_listas em listas, fazemos o que está abaixo:"""

#Para transformar em lista - Pode ser útil caso queira organizar chaves. Ex: imprimir lista com valores em ordem alfabética;
#de forma que todas as "TV's" fiquem juntas, todos os "Iphones", "Ipad's" etc.
vendas_tecnologia1 = {'Iphone': 15000, 'Samsung galaxy': 12000, 'Tv Samsung': 10000, 'Ps5': 14300, 'Tablet': 1720, 'Ipad': 1000, 'Tv Philco': 2500, 'Laptop Hp': 1000, 'Laptop Dell': 17000,  'Laptop Asus': 24500}
chaves1 = vendas_tecnologia1.keys()
valores1 = vendas_tecnologia1.values()
print("-" * 240)
#Ordenando a lista de chaves
lista_chaves1 = list(chaves1)
lista_chaves1.sort()
print(lista_chaves1)
for chave in lista_chaves1:
    print(f"{chave}: {vendas_tecnologia[chave]} unidades.")

"""TRANSFORMANDO LISTAS EM DICIONÁRIOS E FUNÇÃO ZIP"""

#Estrutura:
#Dicionário com valores padrão:
#dicionario = dict.fromkeys(lista_chaves, valor_padrao)
#Dicionário a partir de tuplas:
#dicionario = dict(lista_tuplas)
#Dicionário a partir de duas listas
#Passo 1 - tranformar listas em listas de tuplas com o método zip. Passo 2 - transformar em dicionário
#lista_tuplas = zip(lista1, lista2) dicionario = dict(lista_tuplas)

produtos = ['Iphone', 'Samsung Galaxy', 'Tv Samsung', 'Ps5', 'Tablet', 'Ipad', 'Tv Philco', 'Notebook Hp', 'Notebook Dell']
vendas = [15000, 12000, 10000, 14300, 1720, 1000, 2500, 1000, 17000]
dicionario = dict.fromkeys(produtos, 0) #este metodo faz com que a lista produtos seja a 'chave' do meu dicionário, porém com valor padrão fixo
print(dicionario)

#Transformar listas em tuplas e tuplas em dicionário
produtos = ['Iphone', 'Samsung Galaxy', 'Tv Samsung', 'Ps5', 'Tablet', 'Ipad', 'Tv Philco', 'Notebook Hp', 'Notebook Dell']
vendas = [15000, 12000, 10000, 14300, 1720, 1000, 2500, 1000, 17000]
lista_tuplas = zip(produtos, vendas)
#for item in lista_tuplas:
    #print(item)
print("-" * 180)
dicionario_vendas = dict(lista_tuplas)
print(dicionario_vendas)
print("-" * 180)
#Quanto vendeu de Ipad. Fazendo primeiro com listas

#Quanto vendeu de Ipad? Fazendo primeiro com listas separadas.
produtos = ['Iphone', 'Samsung Galaxy', 'Tv Samsung', 'Ps5', 'Tablet', 'Ipad', 'Tv Philco', 'Notebook Hp', 'Notebook Dell']
vendas = [15000, 12000, 10000, 14300, 1720, 1000, 2500, 1000, 17000]
indice = produtos.index('Ipad')
print("Vendemos {} Ipads.".format(vendas[indice]))
print("-" * 180)
#Fazendo o mesmo, porém com dicionário. Vantagem = acesso à chave e ao valor de uma vez.
lista_tuplas = zip(produtos, vendas)
dicionario_vendas = dict(lista_tuplas)
print("Vendemos {} Ipads.".format(dicionario_vendas['Ipad']))

"""EXERCÍCIO MENOS PRÁTICO PARA TREINAR MANIPULAÇÃO DE DICIONÁRIO - Transforme as listas abaixo em um único dicionário."""

produtos = ['Iphone', 'Galaxy', 'Ipad', 'Tv', 'Maquina de Cafe', 'kindle', 'Geladeira','Adega', 'Notebook Dell']
vendas2019 = [558147, 712350, 573823, 405252, 718654, 531580, 973139, 892292, 422760]
vendas2020 = [951642, 244295, 26964, 787604, 867660, 78830, 710331, 646016, 694916]
#Código aqui:
lista_vendas = list(zip(vendas2019, vendas2020))
vendas_produtos = dict(zip(produtos, lista_vendas))
print(vendas_produtos)

"""ITERABLE - estrutura que armazena dados que podem ser iterados, isto é, aceita loop como, p. ex, o for que passa item a item. É como se fosse um tipo de lista de coisas que você pode ir olhando cada um dos elementos dentro da estrutura.Ex - tuplas, dicionários, listas, string, etc."""

#Estrutura do range (tb é iterable):
#range(tamanho)
#range(início, fim)
#range(inicio, fim, passo)

#Uso mais comum no for:
produtos = ['arroz', 'feijão', 'macarrão', 'atum', 'azeite']
estoque = [50, 100, 20, 5, 80]

for i in range(5):
    print("{}: {} unidades.".format(produtos[i], estoque[i]))

"""Exemplo: Modelo Jack Welch da G&E - 1. Classe A: 10% melhor. 2.Classe B: 80% mantém/busca melhorar. Classe C: 10% pior demitido."""

funcionarios = ['Maria', 'José', 'Antonio', 'João', 'Francisco', 'Ana', 'Luis', 'Paulo', 'Carlos', 'Manoel', 'Pedro', 'Francisco', 'Carlos', 'Priscila', 'Camila', 'Amanda', 'Ronilda', 'Vitor', 'Lennon', 'Harrison']
vendas = [2750, 1900, 1500, 1200, 1111, 1100, 999, 900, 880, 870, 800, 800, 450, 400, 300, 300, 120, 90, 80, 70]
#Quem são os fiuncionários da classe B
for i in range(2, 18):
    print('{}: fez {}'.format(funcionarios[i], vendas[i]))

"""SET - Estrutura - meu_set = {valor, valor, valor, valor...} Obs: não pode ter valores duplicados e não tem ordem fixa. É util para contagem distintas, como p. ex, contagem de clientes que compraram na loja, etc."""

cpf_clientes = ['268.758.440-10', '268.758.440-10', '333.623.890-07', '616.427.810-45', '633.070.750-20', '043.521.990-10', '485.154.910-52', '548.119.990-45', '741.610.730-03', '767.849.980-90', '508.226.320-04', '005.915.240-07', '807.357.920-03']
#temos 13 cpfs e se tiver repetidos, por ser lista, não teria como contabilizar os repetidos. Façamos um set
print(len(cpf_clientes))
set_cpf_clientes = set(cpf_clientes)
print(set_cpf_clientes) # o cpf repetido não se repete aqui
#cpfs unicos, tranformando o set em lista
lista_cpf_set = list(set_cpf_clientes)
lista_cpf_set.sort()
print(f"{len(lista_cpf_set)} pessoas compraram na loja.")

"""PYTHON IMPRESSIONADOR - FUNCTION - FUNÇÕES - BLOCO DE CÓDIGOS PARA EXECUTAR UMA AÇÃO ESPECÍFICA."""

#Estrutura básica
#def nome_funcao():
#   faça alguma coisa
#   faça outra coisa
#   return_valor final

"""Crie uma função de cadastro de um produto que garanta que o produto cadastrado esteja em letras minúsculas:"""

def cadastrar_produto():
    produto = input("Digite o nome do produto que deseja cadastrar: ")
    produto = produto.casefold()
    produto = produto.strip() #Conserta os espaços antes e depois das palavras
    return produto
variavel_produto = cadastrar_produto()
print(variavel_produto)

"""PYTHON IMPRESSIONADOR - ARGUMENTOS/PARÂMETROS DA FUNÇÃO

Crie uma função como parâmetro a fim de categorizar os produtos de uma revendedora de bebidas. Cada produto tem um código. O tipo de produto é dado pelas 3 primeiras letras do código. Ex: Vinho -> BEB12302, Cerveja -> BEB12043, Vodka -> BEB3451, Guaraná -> BSA1104, COCA -> BSA5401, Sprite -> BSA34012, Água -> BSA09871. Repare que as bebidas não alcólicas começam com BSA e bebidas alcóolicas começam com BEB. Crie um programa que analise uma lista de produtos e envie instruções para a equipe de estoque dizendo quais produtos devem ser enviados para a área de bebidas alcóolicas.
"""

def ehalcoolico(bebida):
    bebida = bebida.upper()
    if 'beb' in bebida:
        return True
    else:
        return False

produtos = ['beb46275', 'TFA23962', 'TFA64715', 'TFA69555', 'TFA56743', 'BSA45510', 'TFA44498', 'CAR75448', 'CAR23596', 'CAR569875', 'BEB21365', 'CAR336548', 'BEB31623', 'TAF65321', 'BEB85146', 'CAR45673', 'beb34659', 'CAR36521', 'BEB22345', 'CAR21345', 'BEB22365']

for produto in produtos:
    if ehalcoolico(produto):
        print(f"Enviar {produto} para setor de bebidas alcóolicas.")

"""MAIS DE UM ARGUMENTO E FORMAS DE PASSAR ARGUMENTO PARA A FUNÇÃO"""

def eh_da_categoria(bebida, cod_categoria):
    bebida = bebida.upper()
    if cod_categoria in bebida:
        return True
    else:
        return False

produtos = ['beb46275', 'TFA23962', 'TFA64715', 'TFA69555', 'TFA56743', 'BSA45510', 'TFA44498', 'CAR75448', 'CAR23596', 'CAR569875', 'BEB21365', 'CAR336548', 'BEB31623', 'TAF65321', 'BEB85146', 'CAR45673', 'beb34659', 'CAR36521', 'BEB22345', 'CAR21345', 'BEB22365']

for produto in produtos:
  # if eh_da_categoria(cod_categoria = 'BEB', bebida = produto) outra forma de passar parâmetro, porém por meio de palavra chave(keyword)
    if eh_da_categoria(produto, 'BEB'):
        print(f"Enviar {produto} para setor de bebidas alcóolicas.")
    elif eh_da_categoria(produto, 'BSA'):
        print(f"Enviar {produto} para a categoria de bebidas não alcóolicas.")

"""FUNÇÃO PARA CÁLCULO DE CARGA TRIBUTÁRIA - Exercício - Para fazer um treino simples antes de avançarmos em mais functions, vamos criar uma função que resolve um desafio "simples". Crie uma função que calcule qual o % de carga tributária que está sendo aplicado sobre um determinado produto, dado que o preço de venda, o lucro e os custos (com exceção do imposto) dele."""

# A função deve calcular sobre o preço total
def carga_tributaria(preço, custo, lucro): #se pressionar shift e tab encima da função, aparece a explicação sobre o que ela faz (no jupiter anaconda)
    imposto = preço - custo - lucro
    carga = imposto / preço
    return carga

preço = 1500
custo = 400
lucro = 800

print("{:.1%}".format(carga_tributaria(preço, custo, lucro)))

#Função para padronizar codigos de produtos:
def padronizar_codigos(lista_codigos, padrao = 'm'):
    for i, item in enumerate(lista_codigos):
        item = item.replace('  ', ' ' )
        item = item.strip()
        if padrao == 'm':
            item = item.casefold()
        elif padrao == 'M':
            item = item.upper()
        lista_codigos[i] = item
    return lista_codigos
cod_produtos = ['  ABC12', 'abc34', 'abc37','  AFV12']
print(padronizar_codigos(cod_produtos, 'M'))

"""RETURN - Podemos usar no return praticamente qualquer tipo de objeto(número, string, lista, tupla, dicionário, outros objetos, etc). O return se for executado, encerra a função mesmo que dentro dela haja um loop."""

#retornar um número:
def minha_soma(num1, num2, num3):
    return num1 + num2 + num3
#retornar um texto:
def padronizar_texto():
    texto = texto.casefold()
    texto = texto.replace("  ", " ")
    texto = texto.strip()
    return texto
#retornar um boolean
def bateu_meta(vendas, meta):
    if vendas >= meta:
        return True
    else:
        return False
#Retornar uma lista, tupla ou dicionário
def filtar_lista_texto(lista, pedaco_texto):
    lista_filtrada = []
    for item in lista:
        if pedaco_texto in item:
            lista_filtrada.append(item)
    return lista_filtrada

"""PYTHON IMPRESSIONADOR EXERCÍCIOS FUNÇÕES - Crie uma função que calcula o percentual de stockout de uma empresa. O percentual % de stockout é dado por (Vendas Perdidas por Estoque) / (Vendas concluídas + Vendas perdidas por Estoque) -> essas vendas são dadas em valor total (dinheiro)  e não em quantidade de vendas. Seu programa deve receber um dicionário com todas as vendas da empresa, o status dela(se foi concluída ou Cancelada) e, caso tenha sido cancelada, o motivo do cancelamento. Eis abaixo o formato:"""

#vendas = {
#    'VE0001': (15000, 'concluído', '')
#    'VE0002': (13300, 'Cancelado' 'Cancelado pelo Cliente')
#    'VE0003': (12000, 'Concluído')
#    ...
#}

def calculo_stockout(dicionario_vendas):
    numerador = 0
    denominador = 0
    for venda in dicionario_vendas:
        valor, status, motivo = dicionario_vendas[venda]
        if status == 'Concluído':
            denominador += valor
        elif status == 'Cancelado' and motivo == 'Estoque em falta':
            denominador += valor
            numerador += valor
    return numerador / denominador

vendas = {'VE001': (9868, 'Concluído', ''), 'VE0002': (9642, 'Concluído', ''), 'VE003': (6007, 'Concluído', ''), 'VE0004': (15562, 'Concluído', ''), 'VE0005': (18572, 'Cancelado', 'Estoque em falta'), 'VE006': (16358, 'Cancelado', 'Estoque em falta')}

print("{:.2%}".format(calculo_stockout(vendas)))

"""EXERCÍCIO - Crie uma função para descobrir os clientes inadimplentes de uma empresa. O objetivo é identificar quem são os clientes inadimplentes e enviar essa lista de clientes para que o setor de cobrança possa cobrá-los. A função deve então receber uma lista de clientes, analisá-los quanto à inadimplência e retornar uma lista com os inadimplentes (apenas CPF).
Calcula-se a inadimplência da seguinte forma:
1 - Caso o cliente deva mais de 1.000 reais por mais de 20 dias, é considerado inadimplente.
2 - Isto é, caso deva 2.000 reais a 10 dias, não é inadimplente, pois não se passaram 20 dias. Da mesma forma, se tivesse devendo 500 reais por 40 dias, também não é inadimplente, dado que deve menos de 1.000 reais.
3 - As informações vêem no formato (cpf, valor_devido, qtd_dias)
"""

def clientes_inadimplentes(lista_devedores):
    lista_inadimplentes = []
    for cliente in lista_devedores:
        cpf, valor, qtd_dias = cliente
        if valor > 1000 and qtd_dias > 20:
            lista_inadimplentes.append(cpf)
    return(lista_inadimplentes)

clientes_devedores = [('462.286.561-65', 14405, 24), ('251.569.170-81', 16027, 1), ('297.681.579-21', 8177, 28), ('790.223.154-40', 9582, 15), ('345.556-155-50', 3000, 10), ('325.897.909-70', 5500, 40), ('355.269.651-80', 9875, 10), ('255.356.788-50', 3555, 25), ('654.279.659-98', 3214, 10), ('897.254.364-80', 3214, 15)]

print(f" Os cpfs devedores são: {clientes_inadimplentes(clientes_devedores)}")

"""RETORNO DE MAIS DE UM OBJETO - para tal, basta retornar como uma tupla com 2 itens. Exemplo abaixo:"""

def operacoes_basicas(num1, num2):
    soma = num1 + num2
    diferenca = num1 - num2
    mult = num1 * num2
    divisao = num1 /num2
    return(soma, diferenca, mult, divisao)
print(operacoes_basicas(30, 3))

"""FUNÇÃO PARA CÁLCULO DO PERCENTUAL - Crie uma função que consiga identificar os vendedores que bateram uma meta, mas que também dê como resposta o calculo percentual % da lista de vendedores que bateram a meta. Essa função deverá receber 2 informações como parâmetro: a meta e um dicionário com os vendedores e suas vendas. O retorno deverá ter duas respostas: o nome dos vendedores que bateram a meta e o % de vendedores que bateram a meta."""

def calculo_meta(meta, vendas):
    bateram_meta = []
    for vendedor in vendas:
        if vendas[vendedor] >= meta:
            bateram_meta.append(vendedor)
    perc_bateram_a_meta = len(bateram_meta) / len(vendas)
    return perc_bateram_a_meta, bateram_meta





meta = 10000
vendas = {
    'João': 15000,
    'Julia': 27000,
    'Marcus': 9900,
    'Maria': 3750,
    'Ana': 10300,
    'Alon': 7870,
}

print(calculo_meta(meta, vendas))
#Fazendo o unpacking das tuplas e passando-as para variáveis independentes:
p_meta, vendedores_acima_da_meta = calculo_meta(meta, vendas)
print("{:.1%} dos vendedores bateram a meta.".format(p_meta))
print("A lista de nomes que bateram a meta é: {}.".format(vendedores_acima_da_meta))

"""Aplicação muito usada em data science e IA. Quando criamos um modelo de previsão, precisa-se treina-lo testando-o para saber se ele funciona. Assim sendo, devemos pegar nossos dados e dividí-los em dois "pedaços", sendo uma lista de treino e outra de testes. Desta forma, pensemos em um modelo que tenta identificar qual o valor justo de um imóvel conforme o tamanho dele. Temos duas listas: 1 - Preço reais dos imóveis. 2 - Tamanho do imóvel. Criemos, então, uma função que receba como entrada e que divida cada uma dessas listas em 2, isto é, um pedaço de treino e um pedaço de teste. O percentual que a lista vai ser dividida é definida por um fator(que também vai ser um parâmetro da função)."""

def separar_listas(precos, tamanhos, fator=0.1):
    if len(precos) == len(tamanhos):
        i = int((1 - fator) * len(precos))
        precos_imoveis_treino = precos[:i]
        precos_imoveis_teste = precos[i:]
        tamanho_imoveis_treino = tamanhos[:i]
        tamanho_imoveis_teste = tamanhos[i:]
        return precos_imoveis_treino, precos_imoveis_teste, tamanho_imoveis_treino, tamanho_imoveis_teste
    else:
        print("As listas não tem o mesmo tamanho")
        return




#Exemplo com 10 itens para teste do modelo
precos_imoveis = [2.17, 1.54, 1.45, 1.94, 2.37, 2.3, 1.79, 1.8, 2.25, 1.37]
tamanho_imoveis = [207, 148, 130, 203, 257, 228, 160, 194, 232, 147]
#Primeiro, vamos definir qual o fator que vamos dividir as listas, quantos % da lista vai ficar para teste. No caso, será 10%:
fator = 0.1 #10%
#Isso significa que a 1ª lista treino terá 1 item. Terá que cortar a lista, mas por onde começa e onde termina?
#Onde terminar a lista de treino e começar a lista de teste?
#Para isso, usa-se a lógica da conta abaixo:
i = int((1 - fator) * len(precos_imoveis)) # se tem 10 itens no preco_imoveis, a conta dará 9, isto é, corta até o indice 9
#Dividindo em duas listas. Uma com 90% dos valores e outra com 10%.
print(separar_listas(preco_imoveis, tamanho_imoveis))

preco_imoveis = [2.17, 1.54, 1.45, 1.94, 2.37, 2.3, 1.79, 1.8, 2.25, 1.37, 2.4, 1.72, 2, 1.69, 1.63, 2.01, 2.25, 1.61, 1.02, 1.19]
tamanho_imoveis = [207, 148, 130, 203, 257, 228, 160, 194, 232, 147, 222, 165, 184, 175, 147, 217, 214, 171, 86, 111]

precos_treino, precos_teste, tamanho_treino, tamanho_teste = separar_listas(preco_imoveis, tamanho_imoveis)
#separando as tuplas criadas pela função em variáveis:
print(precos_treino)
print(precos_teste)
print(tamanho_treino)
print(tamanho_teste)

"""PYTHON IMPRESSIONADOR - TRATAMENTO DE ERROS"""

#"Testar" erros e tratar exceções:
def descobrir_servidor(email):
    try:
        posicao_a = email.index('a')
        servidor = email[posicao_a:]
        print("")
        if 'gmail' in servidor:
            return 'gmail'
        elif 'hotmail' in servidor or 'outlook' in servidor or 'live' in servidor:
            return 'hotmail'
        elif 'yahooo' in servidor:
            return 'yahoo'
        elif 'uol' in servidor or 'bol' in servidor:
            return 'uol'
        else:
            return 'não determinado'
    except:
        raise TypeError('Email digitado com caracteres errados.')

email = input("Qual o seu email? ")

"""PERSONALIZANDO A MENSAGEM DE ERRO:"""

#except:
       # raise Exception('Email digitado com caracteres errados.')
#raise TypeError('O erro foi esse')
#raise ValueError('O erro foi esse')
#raise ZeroDivisionError('O erro foi esse')

"""QUANTIDADE INDEFINIDA DE ARGUMENTOS - quando se utiliza quantidade indefinida de argumentos, usamos o * para tal.

"""

#Estrutura
#args para psotional arguments -> argumentos vêm em formato de tupla
#def minha_funcao(*args):
#   ...

#kwargs para keyword arguments -> argumentos vêm em formato de dicionário
#def minha_funcao(**kwargs):
#   ...

#Exemplo:
def minha_soma(*numeros):
    soma = 0
    for numero in numeros:
        soma += numero
    return soma
print(minha_soma(1, 3, 4, 50, 24))

#Exemplo de argumentos keywords
def preco_final(preco, **adicionais): #**adicionais pode agrupar quantos keywords forem necessários, sendo que devemos passar uma 'chave' e um valor.
    print(adicionais)
    if 'desconto' in adicionais:
        preco *= (1 - adicionais['desconto'])
    if 'garantia_extra' in adicionais:
        preco += adicionais['garantia_extra']
    if 'imposto' in adicionais:
        preco *= (1 + adicionais['imposto'])
    return preco
#exemplo:
print(preco_final(1000, desconto = 0.1, garantia_extra = 100, imposto = 0.3))

"""ORDEM DOS ARGUMENTOS - Estrutura - sempre os "positional arguments" vêm antes e depois os "kwargs". Sempre os argumentos individuais vêm antes e depois vêm os multiplos."""

#Exemplo
#def minha_funcao(arg1, arg2, arg3, arg4, *args, k = kwarg1, k2 = kwarg2, k3 = kwarg3, **kwargs):
#   ...

"""Digamos que você receba 2, 3, 5, ou até 10 bases com a posição em estoque de vários produtos. Assim, crie uma função que pega todas essas listas e cria, a partir dela(s), uma lista de produtos. A função pode receber, 1, 2, 3, ou quantas listas de estoque forem necessárias. Obs: lembre-se dos sets para fazer a lista de produtos não ter produtos repetidos.

"""

def listar_produtos(*listas):
    for lista in listas:
        lista_produtos = []
        for produto, estoque in lista:
            lista_produtos.append(produto)
    lista_produtos = set(lista_produtos) #para retirar valores duplicados
    lista_produtos = list(lista_produtos)#para voltar a ser lista
    return lista_produtos


estoque_fim_jan = [('BSA234', 234), ('PPF256', 221), ('PPR234', 234), ('SSA345', 345), ('VMA345', 334), ("BSA234", 322), ('DFG234', 233), ('FGR234',234)]
estoque_fim_fev = [('BSS234', 234), ('PPF256', 221), ('DDR234', 234), ('SAD345', 345), ('VMA345', 334), ("BSB234", 322), ('AFG234', 233), ('FGQ234',234)]
estoque_fim_marco = [('BSA234', 234), ('PPF256', 221), ('PWR234', 234), ('SSA345', 345), ('VWW345', 334), ("WSA234", 322), ('DFG234', 233), ('FGR234',234)]
estoque_fim_abril = [('BSA234', 234), ('KPF256', 221), ('PPR134', 234), ('SSA345', 345), ('AMA345', 334), ("BSA234", 322), ('DFG234', 233), ('FGR234',234)]

print(listar_produtos(estoque_fim_jan, estoque_fim_fev, estoque_fim_marco, estoque_fim_abril))

"""PYTHON IMPRESSIONADOR - INTRODUÇÃO À PROGRAMAÇÃO ORIENTADA A OBJETO - Regras Gerais: Tudo no python é um objeto, string, lista, dicionários, variáveis etc.
Modulos - existem centenas de milhares de modulos prontos e não precisamos nos preocupar em criar do zero. Estrutura basica: import modulo ou import modulo as nome. exemplo: fazer o python abrir um site na net.
"""

#Não funciona no colab - mas funfa no pycharm etc.
import webbrowser
webbrowser.open("https://google.com")

"""Importar parte do modulo, sem importá-lo por completo:
from modulo import *
from modulo import função1, função2, função3

MODULO TIME - também existe o módulo datetime, mas vamos focar agora no modulo time.
"""

import time
data_hoje = time.ctime()
print(data_hoje)

#Pegar infos detalhadas de segundos, minutos, horas...
data_atual = time.gmtime()
print(data_atual)
print('-' * 180)
#pegando separado
ano = data_atual.tm_year
mes = data_atual.tm_mon
dia = data_atual.tm_mday
print(f"Hoje é {dia}/{mes}/{ano}.")
#tembém há a opção de pegar por índices, mas normalmente se usa acomo acima.

#calculando tempo de rodagem de um programa
import time
tempo_inicial = time.time()
for i in range(100000000):
    pass
tempo_final = time.time()
duracao = tempo_final - tempo_inicial
print("O programa levou {} segundos para rodar".format(duracao))

"""USANDO MODULOS PARA RESOLVER DESAFIOS"""

#Método que passa o maior valor do dicionário em ordem do maior para o menor valor
from collections import Counter
vendas_tecnologia = {'notebook asus': 2450, 'iphone': 15000, 'samsung galaxy': 12000, 'tv samsung': 10000, 'ps5': 14300, 'tablet': 15000, 'Lenovo': 55000, 'HD externo': 5000, 'Ecrã': 14000}
aux = Counter(vendas_tecnologia)
print(aux)
#se quiser os 3 primeiros maiores valores, p. ex, o método é:
print(aux.most_common(3))

"""EXIBINDO GRÁFICOS NO PYTHON - bom para exploração e visualização dos dados. Usaremos o módulo Matplotlib.pyplot, que é o módulo mais usado em python. Existem outros, como o Seaborn e o Ploty, caso queira ver/usar."""

vendas_meses = [1500, 1727, 1350, 999, 1050, 1027, 1022, 1500, 2000, 1433, 2100, 2762]
meses = ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez']
#Plotar gráfico de uma forma simples
import matplotlib.pyplot as plt
plt.plot(meses, vendas_meses) #meses corrsponde ao eixo x e vendas_meses ao eixo y
#Adicionando label(nome) no eixo x e no eixo y:
plt.ylabel('Vendas')
plt.xlabel('Meses')
#alterando e editando os eixos
plt.axis([0, 12, 0, max(vendas_meses) + 150])
#Show é a ultima etapa para aparecer o gráfico com as modificações.
plt.show()

"""PYTHON IMPRESSIONADOR - MAIS EDIÇÕES COM GRAFICOS - MATPLOT LIB"""

import matplotlib.pyplot as plt
import numpy as np
vendas_meses = [1500, 1727, 1350, 999, 1050, 1027, 1022, 1500, 2000, 1433, 2100, 2762]
meses = ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez']
vendas = np.random.randint(1000, 3000, 50) #gera numeros aleatórios entre 1000, maximo 3000, 50 números.
meses = np.arange(1, 51)
plt.plot(meses, vendas, 'go--', color = 'red') #editando o gráfico e linha com 'ro' - tuda a formatação está registrada no matplotlib.org
plt.ylabel('Vendas')
plt.xlabel('Meses')
plt.axis([0, 50, 0, max(vendas_meses) + 200])
plt.show()

#Gráfico de dispersão:
plt.scatter(meses, vendas, color = 'red')
plt.show()

#gráfico com barras
plt.bar(meses, vendas, color = 'blue')
plt.show()

#colocando os gráficos lado a lado ou abaixo um do outro.
plt.figure(1, figsize=(15, 3)) #figsize configura o tamanho do gráfico (altura x largura)
plt.subplot(1, 3, 1) #subplot pede 3 numeros inteiros (nrows, ncols, index) - n.de linhas, n.de colunas e n.de índices
plt.plot(meses, vendas, color = 'red')
plt.subplot(1, 3, 2)
plt.scatter(meses, vendas, color = 'orange')
plt.subplot(1, 3, 3)
plt.bar(meses, vendas, color = 'blue')
plt.show()

import matplotlib.pyplot as plt
import numpy as np
fig = plt.figure()
aux = fig.gca(projection='3d')
def f(x,y):
    return x**2 + y**2
x = np.linspace(-6, 6, 30)
y = np.linspace(-6,6,30)
x, y = np.meshgrid(x,y)
z = f(x,y)
ax = plt.axes(projection='3d')
ax.plot_wireframe(x,y,z, color='aqua')
ax.set_title('Teste 3d')

#exemplo para o pycharm
import keyboard
keyboard.press_and_release('ctrl + t')
keyboard.write('www.google.com')
keyboard.press_and_release('enter')

"""PYTHON IMPRESSIONADOR - LIST COMPREHENSION - forma de iterar pelos elementos das listas de maneira "mais direta", com mais "cara" de python. Em resumo, é como se fosse um 'for' em uma linha de código. Estrutura: lista = [expressão for item in iterable]

"""

preco_produtos = [100, 150, 300, 5500]
lista_produtos = ['vinho', 'cafeteira', 'microondas', 'iphone']
#Digamos que há imposto de 30% sobre os produtos, ou seja, 0.3. Crie uma lista com os valores de imposto de cada produto
#fazendo com for normal
impostos = []
for item in preco_produtos:
    impostos.append(item * 0.3)
print(impostos)

#Agora com list comprehension
preco_produtos = [100, 150, 300, 5500]
lista_produtos = ['vinho', 'cafeteira', 'microondas', 'iphone']
impostos = [preco * 0.3 for preco in preco_produtos]
print(impostos)

"""TAMBÉM PODEMOS UTILIZAR O LIST COMPREHENSION JUNTO COM UMA FUNÇÃO:"""

def calcular_imposto(preco, imposto):
    return preco * imposto
preco_produtos = [100, 150, 300, 5500]
lista_produtos = ['vinho', 'cafeteira', 'microondas', 'iphone']
impostos = [calcular_imposto(preco, 0.3) for preco in preco_produtos]
print(impostos)

"""EXEMPLO PRÁTICO DE LIST COMPREHENSION - ordenando 2 listas "relacionadas"."""

#Ordenando do produto que mais vende para o que menos vende
vendas_produtos = [1500, 150, 2100, 1950]
produtos = ['vinho', 'cafeteira', 'microondas', 'iphone']
lista_aux = list(zip(vendas_produtos, produtos)) # ZIP vai juntar cada um dos itens dessas listas, mas é necessário transformá-lo em lista (list)
lista_aux.sort(reverse = True) # ao invocarmos o sort, neste caso, pega-se o 1 item de cada tupla
print(lista_aux)
produtos = [produto for vendas, produto in lista_aux] # inteção desta linha é pegar somente o produto que mais vende, por meio do list comprehension (produto = 1 item - vendas = 2 item)
print(produtos)

"""EXERCÍCIO DE LIST COMPREHENSION - Tirando infos de listas e dicionários. Digamos que você está analisando as vendas de produtos de uma empresa de varejo. Essa lista tem: (produto, vendas de 2019, vendas de 2020) para cada produto. Crie uma lista com as vendas de 2019."""

vendas_produtos = [('iphone', 558147, 951642), ('galaxy', 712350, 244295), ('ipad', 573823, 269664), ('tv', 405252, 787604)]
#sem list comprehension
lista_vendas2019 = []
for produto, vendas2019, vendas2020 in vendas_produtos:
    lista_vendas2019.append(vendas2019)
print(lista_vendas2019)
print('-' * 180)
#Solução com list comprehension
vendas_2019 = [vendas19 for produto, vendas19, vendas20 in vendas_produtos]
print(vendas_2019)
print('-' * 180)
#Qual o maior valor de vendas de 2019?
print(max(vendas_2019))
print('-' * 180)
#Qual produto que mais vendeu em 2019?
vendas_2019 = [(vendas19, produto) for produto, vendas19, vendas20 in vendas_produtos] #proposital o numero ser o primeiro item da tupla porque as funções max, min e sum pegam por ele
print(max(vendas_2019))

"""LIST COMPREHENSION COM IFS PARA FILTRAR ITENS - Estrutura: lista = [expressão for item iterable if condição]"""

#lista de produtos que bateram a meta
meta = 1000
vendas_produtos = [1500, 150, 2100, 1950]
produtos = ['vinho', 'cafeitera', 'microondas', 'iphone']
#solução sem list comprehension
acima_meta = []
for i, produto in enumerate(produtos):
    if vendas_produtos[i] > meta:
        acima_meta.append(produto)
print(acima_meta)
print('-' * 180)
#solução com list comprehension
produtos_acima_meta = [produto for i, produto in enumerate(produtos) if vendas_produtos[i] > meta]
print(produtos_acima_meta)

"""SE O VENDEDOR BATEU A META - Digamos que eu esteja analisando os vendedores de uma loja e queira criar uma lista para enviar para o RH com bônus para cada vendedor. O bônus é dado por 10% do valor de vendas dele, caso ele tenha batido a meta."""

vendedores_dic = {'Maria': 1200, 'José': 300, 'Antônio': 800, 'João': 1500, 'Francisco': 1900, 'Ana': 2750, 'Luiz': 400, 'Vitor': 3000, 'Carlos': 3200, 'Vânia': 900, 'Amélia': 1200, 'Carmélia': 2300, 'Flávia': 550, 'Jordi': 2000, 'Lobato': 660, 'Evandro': 1000, 'Pablo': 2200, 'Lívia': 400}

meta = 1000
bonus = []
for i in vendedores_dic:
    if vendedores_dic[i] > meta:
        bonus.append(vendedores_dic[i] * 0.1)
    else:
        bonus.append(0)
print(f'{bonus}')

"""Fazendo com List Comprehension - estrutura: lista = [item if condicao else outro_resultado for item in iterable]"""

vendedores_dic = {'Maria': 1200, 'José': 300, 'Antônio': 800, 'João': 1500, 'Francisco': 1900, 'Ana': 2750, 'Luiz': 400, 'Vitor': 3000, 'Carlos': 3200, 'Vânia': 900, 'Amélia': 1200, 'Carmélia': 2300, 'Flávia': 550, 'Jordi': 2000, 'Lobato': 660, 'Evandro': 1000, 'Pablo': 2200, 'Lívia': 400}

meta = 1000

bonus = [vendedores_dic[item] * 0.1 if vendedores_dic[item] > meta else 0 for item in vendedores_dic]
print(bonus)

"""Exercício final de List Comprehension - Intuito = avaliar o estoque de uma empresa. Considere que todos os produtos dessa empresa são comprados em loted de 500 unidades. Caso o estoque esteja abaixo de 1000 unidades, devemos fazer um pedido de 500 unidades. Caso o estoque esteja abaixo de 200 unidades, devemos fazer um pedido de 1000 unidades. Defina o valor a ser pedido de cada produto para enviar ao time de compras."""

estoque = [('BSA2199', 396), ('PPF5239', 251), ('BSA1212', 989), ('PPF2154', 449), ('BEB3410', 241), ('PPF8999', 241), ('EMB9591', 601), ('PMM2345', 199)]
lista_pedido = []
for produto, qtd in estoque:
    if qtd < 200:
        lista_pedido.append(1000)
    else:
        lista_pedido.append(500)
print(lista_pedido)

"""Com list Comprehension"""

estoque = [('BSA2199', 396), ('PPF5239', 251), ('BSA1212', 989), ('PPF2154', 449), ('BEB3410', 241), ('PPF8999', 241), ('EMB9591', 601), ('PMM2345', 199)]
lista_pedido2 = [1000 if qtd < 200 else 500 for produto, qtd in estoque]
print(lista_pedido2)

"""LIST COMPREHENSION não serve somente para criar listas, mas para quelquer ação em iteráveis. Exemplo: vamos calcular quantos % das vendas o meu top 5 produtos representa das minhas vendas totais."""

produtos = ['coca', 'pepsi', 'guaraná', 'skol', 'brhama', 'água', 'del valle', 'dolly', 'red bull', 'cachaça', 'vinho tinto', 'brahma', 'skol', 'leite de castanha', 'água de côco', 'barra de proteína', 'Whey Protein', 'Abduzido', 'Leite de amendoas', 'Chocolate', 'Biscoito', 'Cigarro', 'Heineken']
vendas = [1200, 300, 800, 1500, 1900, 2750, 400, 20, 23, 70, 90, 80, 1100, 999, 900, 880, 870, 50, 1111, 120, 300, 450, 800]
top5 = ['agua', 'brahma', 'skol', 'leite de amendoa']
total_top5 = 0
for i, produto in enumerate(produtos): # o i significa cada um dos índices da lista e o produto cada um dos produtos da lista
    if produto in top5:
        total_top5 += vendas[i]
print(total_top5)
print('O top 5 representou {:0.1%} das vendas.'.format(total_top5/sum(vendas)))
print('-' * 180)
#Agora com List Comprehension
lista_total_top5 = sum(vendas[i] for i, produto in enumerate(produtos) if produto in top5)
print(lista_total_top5)
print('O top 5 representou {:0.1%} das vendas.'.format(total_top5/sum(vendas)))

"""FUNÇÕES EM ITERÁVEIS: SEGUE A MESMA LÓGICA DE LIST COMPREHENSION, PORÉM É MAIS SIMPLES. Basicamente alguns métodos e funções que já existem no Python podem rodar uma função para cada item, da mesma forma que fizemos com o list comprehension. Isso pode ajudar a gente a resolver alguns desafios de forma mais simples. Uma função permite que a gente faça tal coisa é a map function. Ex: #Map funtion: lista = list(map(função, iterable_original)). A função map, na verdade, aplica uma determinada função, seja do próprio python ou criada pelo programador, para cada item do iterável (iterable).

Digamos que eu tenha uma função que corrige um código de um produto(semelhante ao que fizemos na seção de função do curso Python Impressionador).
"""

def padronizar_texto(texto):
    texto = texto.casefold()
    texto = texto.replace(" ", " ")
    texto = texto.strip()
    return texto

produtos = [' ABC12  ', 'abc34', 'AbC37', 'beb12', 'BSA151', 'BEB23']
#Usando o for
for i, produto in enumerate(produtos):
    produtos[i] = padronizar_texto(produto)
print(produtos)
#Agora faremos usando o map
produtos = list(map(padronizar_texto, produtos))
print(produtos)

"""Python Impressionador - Sort ou Sorted com função. A diferença é que, p. ex, o lista.sort() modifica a lista original e o sorted retorna um valor, isto é, precisa-se atribuir uma variável ao invés de modificar a lista original."""

#exemplo com sort() - ordena os valores
produtos = ['apple tv', 'mac', 'iphone x', 'Iphone11', 'ipad', 'apple watch', 'mac book', 'airpods']
produtos.sort()
print(produtos)
print('-' * 180)
#exemplo com sorted()
lista_nova = sorted(produtos)
print(lista_nova)

"""O sort() na verdade, coloca em ordem conforme a lógica tabela ASCII, ou seja a ordem dos caracteres."""

#Usando o sort() para ordenar com parâmetro dentro da função sort, aplicando-o para cada item do iterable
produtos = ['apple tv', 'mac', 'iphone x', 'Iphone11', 'ipad', 'apple watch', 'mac book', 'airpods']
produtos.sort(key=str.casefold)
print(produtos)

"""Usando a função sort() com função criada pelo programador"""

def segundo_item(tupla):
    return tupla[1]

vendas_produtos = {'vinho': 100, 'cafeteira': 150, 'microonda': 300, 'iphone': 5500}
#listar da maior quantidade de vendas para a menor
#Primeiro passo é tranformar o dicionário em uma lista, e a melhor forma de fazer isso é tranformá-lo em uma lista de tuplas
lista_vendas = list(vendas_produtos.items()) #função que tranforma cada item do dicionário em uma tupla

#criar uma função que ordene a lista de tuplas pelo valor, ou seja, pelo segundo item da tupla.
lista_vendas.sort(key=segundo_item) #ordem crescente
print(lista_vendas)
lista_vendas.sort(key=segundo_item, reverse=True)#ordem decrescente
print(lista_vendas)
#Se quiser tranformar a lista em dicionário:
print(dict(lista_vendas))

"""PYTHON IMPRESSIONADOR - EXPRESSÕES LAMBDAS - as lambdas são funções anônimas que tem 1 linha de código e são atribuídas a uma variável, como se a variável virasse uma função. Elas normalmente são utilizadas para executar uma única ação, mas em Python usamos principalmente dentro de métodos como argumentos para não precisarmos criar uma função só para isso(vamos ver isso na aula que vem). Outra aplicação dela é a criação de um "gerador de funções" (aula3).
Obs: não é obrigatório o uso das funções lambdas, porém é importante entendê-las quando a encontrarmos e saber usá-las conforme a necessidade. Estrutura: minha_funcao = lambda parâmetro: expressão.
"""

#Função que poderia ser lambda
def funcao(num):
    return num * 2
print(funcao(5))
print('-' * 180)
#Exempo da função acima, porém como lambda:
minha_funcao = lambda num: num * 2
print(minha_funcao(5))

"""Exemplo útil que usa lambda para calcular o preço dos produtos acrescido imposto:"""

#Exemplo com função normal
def preco_imposto(preco):
    return preco * (1 + 0.3)
preco = 250
imposto = 0.3
print(f"O preço com imposto é: {round(preco_imposto(preco), 2)}")
#Exemplo com lambda
preco_imposto = lambda preco: preco * (1 + imposto)
print(f"O com imposto é: {round(preco_imposto(preco), 2)}")

"""A principal aplicação de uma lambda é como argumento de alguma outra função, como map e filter."""

def calcular_preco(preco):
    return preco * 1.3
preco_tecnologia = {'notebook asus': 2450, 'iphone': 4500, 'samsung galaxy': 3000, 'tv samsung': 1000, 'ps5': 3000, 'tablet': 1500}
#Queremos saber o preço de cada produto adicionado o valor de imposto 30% sobre o valor do produto
preco_com_imposto = list(map(calcular_preco, preco_tecnologia.values()))
print(preco_com_imposto)
print('-' * 180)
#Fazendo por lambda
preco_com_imposto2 = list(map(lambda preco: preco * 1.3, preco_tecnologia.values()))
print(preco_com_imposto2)

"""Função filter() - parecida com o map, filtra um iterable. Estrutura: filter(função, iterable) -> retorna como resposta todos os itens do iterable onde a função é True."""

#Fazendo primeiro por função comum:
def ehmaior(item):
    return item[1] > 2000
preco_tecnologia = {'notebook asus': 2450, 'iphone': 4500, 'samsung galaxy': 3000, 'tv samsung': 1000, 'ps5': 3000, 'tablet': 1500}
produtos_acima2000 = dict(list(filter(ehmaior, preco_tecnologia.items())))
print(produtos_acima2000)
print('-' * 180)
#fazendo o exemplo acima por lambda:
produto2_acima2000 = dict(list(filter(lambda item: item[1] > 2000, preco_tecnologia.items())))
print(produto2_acima2000)

"""Lambda para gerar funções: criar função que permita calcular o valor acrescido do imposto de diferentes categorias (produtos, serviços, royalties, etc)"""

def calcular_impostos(imposto):
    return lambda preco: preco * (1 + imposto)
#Calcular preço produto (10%)
# Calcular roalties 25%
#Calcular serviço 15%

calcular_preco_produto = calcular_impostos(0.1)
calcular_preco_roalties = calcular_impostos(0.25)
calcular_preco_servico = calcular_impostos(0.15)

print("{:.2f}".format(calcular_preco_produto(15.35)))
print("{:.2f}".format(calcular_preco_roalties(15.35)))
print("{:.2f}".format(calcular_preco_servico(15.35)))

"""PYTHON IMPRESSIONADOR - INTRODUÇÃO AO PANDAS - Análise de dados (seja para data science, ou para trabalhar de forma integrada com arquivos em Excel e BD). Melhor biblioteca/modulo para trabalhar com quantidades enormes de informações.
Uma mistura de listas e dicionários de uma forma muito eficiente.

Importar um arquivo csv de base de dados dentro do colab
"""

#Comandos para importar arquivos para dentro do colab
from google.colab import files
uploaded = files.upload()

import pandas as pd
#ler arquivo csv - forma mais básica é criar uma variável
vendas_df = pd.read_csv(r'advertising.csv') #comando para ler o arquivo
vendas_df # em vez de mandar 'printar', é melhor executar somente escrevendo a variável, para se obter uma melhor visualização.

#Codigo para que o python leia o nome de um arquivo
from pathlib import Path
file_path = "Desktop/Base de dados para estudo/advertising.csv."
file_name = Path(file_path).stem
print(file_name)

"""AULA PYTHON IMPRESSIONADOR - DATA FRAME - em resumo, ele é como se fosse uma tabela, sendo que as colunas funcionam como "chaves de dicionário" e as linhas funcionam como "listas"."""

vendas_df['Jornal'] #comando para pegar uma só coluna
vendas_df[:3]
#vendas_df[0] daria erro porque nao funciona bem no DF e sempre tem que pegar a partir do cabeçalho
#então seria assim, para nao dar erro e pegar, p. ex, o cabeçalho
vendas_df[:0]
#ou assim:
vendas_df[:1]

"""Pegando mais de uma coluna de uma vez:"""

#Estrutura:
#vendas_df[['coluna_x', 'coluna_y', 'coluna_z']] -> cria um novo dataframe com as colunas: coluna_x, coluna_y e coluna_z.
vendas_df[['Radio', 'TV', 'Vendas']]



"""Pegar um item específico do DF:"""

#Estrutura:
#vendas_df['coluna_x'][0] -> pega, p. ex, o item da 1ª linha da coluna x
vendas_df['Radio'][0]
vendas_df['Radio'][2]

"""APLICAÇÃO:"""



"""Matéria Funções - Curso Python para iniciantes - Uninter"""

#Primeiro exemplo
print("|", '-' * 18, '|')
print("|", '-' * 18, '|')
print('           MENU ')
print("|", '-' * 18, '|')
print("|", '-' * 18, '|')

print('-' * 180)
# Em vez de repetir os prints, use função
def darDestaque():
    print("|", '-' * 18, '|')
    print("|", '-' * 18, '|')

darDestaque()
print('           MENU ')
darDestaque()

#Uso de parâmetro em função
def darDestaque(mensagem):
    print("|", '-' * 18, '|')
    print("|", '-' * 18, '|')
    print('           ',mensagem)
    print("|", '-' * 18, '|')
    print("|", '-' * 18, '|')
darDestaque("Olá")
darDestaque("Mundo")

numeroA = 12 # Essa é uma variável global, pois não está dentro da função
def func():
    numero = 6
    print("func: ", numero) # A variável numero só existe dentro da função

def soma3(x, y, z):
    res = x + y + z
    return res

soma3(10, 25, 99)

def soma3(x, y, z):
    res = x + y + z
    return res
resposta_final = soma3(3, 4, 5) + soma3(20, 30, 45)
resposta_final += 1
print(resposta_final)

#função verifica numero par
def par(num):
    if num%2 == 0:
        print(f"O número {num} é par!")
    else:
        print(f"O número {num} é ímpar!")
par(9)

#Outra opção de número ímpar usando a funçao par dentro da função ímpar
def par(num):
    return num%2 == 0

def impar(num):
    return not par(num)

def imprime_com_condicao(numero,funcao):
    if funcao(numero):
        print(numero)
imprime_com_condicao(50, par)
imprime_com_condicao(1, impar)
#Função lambda dentro da função imprime_com_condição
imprime_com_condicao(10, lambda num : num > 5)

"""Exercícios com funções - 1) Crie uma função que retorne o maior de 3 números passados como parâmetro"""

x= int(input("Digite um valor: "))
y = int(input("Digite um valor: "))
z = int(input("Digite um valor: "))
def maior_de_tres(x, y, z):
    if x >= y and x >= z:
        return x
    elif y >= x and y >= z:
        return y
    elif z >= x and z >= y:
        return z
print(f"A função retorna o maior valor entre 3 números que, neste caso, é o número: {maior_de_tres(x, y, z)}")

"""Utilize o exercício (função) anterior para descobrir o maior dentre 9 números."""

#Utilizando a mesma função acima sem alterá-la, mas somente complementando-a com novos parâmetros criados por meio de 3 variáveis cujos números resultam em 9 números no total
maioral1 = maior_de_tres(60, 70, 20)
maioral2 = maior_de_tres(80, 10, 50)
maioral3 = maior_de_tres(20, 90, 80)
maior_todos = maior_de_tres(maioral1, maioral2, maioral3)
print(maior_todos)

"""Faça uma função chamada quadrado(lado) que recebe como parâmetro um número representando a medida do lado de um quadrado e imprima 3 valores:
Área (lado * lado). Perímetro(4 * lado). Tamanho diagonal (lado v 2).
"""

import math
numero_medida_quadrado = int(input("Digite a medida de um lado do quadrado: "))
def quadrado_lado():
    area = numero_medida_quadrado * numero_medida_quadrado
    perímetro = numero_medida_quadrado * 4
    tamanho_diagonal = numero_medida_quadrado * math.sqrt(2)
    print(f"A área do quadrado é: {area}.")
    print(f"O perímetro do quadrado é: {perímetro}.")
    print(f"O tamano diagonal do quadrado é: {tamanho_diagonal:.2f}.")
quadrado_lado()

import math
def quadrado(lado):
    área = lado * lado
    perímetro = lado * 4
    tamanho_diagonal = math.sqrt(2) * lado
    print(f"A área do quadrado é: {área}.")
    print(f"O perímetro do quadrado é: {perímetro}.")
    print(f"O tamano diagonal do quadrado é: {tamanho_diagonal:.1f}.")

lado = int(input("Digite o lado de um quadrado: "))
quadrado(lado)

"""Faça uma função que recebe um número como parâmetro e retorna se o valor é positivo ou não retornado: True ou False"""

num = int(input("Digite um número: "))
def positivo(num):
    if num > 0:
        print(num)
        return True
    else:
        print(num)
        return False
positivo(num)

"""Escreva uma função que imprima quantas letras em uma string recebida por parâmetro são maiúscula e quantas são minúsculas."""

total_maiúscula = 0
total_minuscula = 0
string = input("Digite uma string: ")


for letra in string:
    if letra.isupper():
        total_maiúscula += 1
    elif letra.islower():
        total_minuscula += 1
print(f"O total de letras maiúsculas = {total_maiúscula} letras")
print(f"O total de letras minúsculas = {total_minuscula} letras")

"""CURSO UNINTER - Python Para Iniciantes - Aula 10 - TUPLAS E LISTAS"""

#TUPLAS EX - NÚMEROS DA MEGA SENA
# indices:           0  1   2   3   4   5
tupla_n_mega_sena = (8, 20, 37, 40, 44, 51)
# índice negativo   -6 -5  -4  -3  -2  -1
print(tupla_n_mega_sena[0])
print(tupla_n_mega_sena[1])
print(tupla_n_mega_sena[2])
print(tupla_n_mega_sena[3])
print(tupla_n_mega_sena[4])
print(tupla_n_mega_sena[5])
print(tupla_n_mega_sena[-1])
print(tupla_n_mega_sena[-2])
print(tupla_n_mega_sena[-3])
print(tupla_n_mega_sena[-4])
print(tupla_n_mega_sena[-5])
print(tupla_n_mega_sena[-6])

tupla_n_mega_sena = (8, 20, 37, 40, 44, 51)
for numero in tupla_n_mega_sena:
    print(numero)
print("-" * 180)
for pos, valor in enumerate(tupla_n_mega_sena):
    print(f"Na posição {pos} temos o valor {valor}.")

"""Conceito de Fatiamento - Slicing"""

tupla_n_mega_sena = (8, 20, 37, 40, 44, 51)
print(tupla_n_mega_sena[:3])
s1 = 'Super Mario'
print(s1[:])
print(s1[::-1])

#Concatenando as Tuplas
tupla_n_mega_sena = (8, 20, 37, 40, 44, 51)
print(tupla_n_mega_sena)
extra = (42, 57)
megaSena_total = tupla_n_mega_sena + extra
print(megaSena_total)

#Tupla como parâmetro de função
def somar(*numeros): # o asterísco significa que vai receber uma coleção de números
    somatorio = 0
    for num in numeros:
        somatorio += num
    return somatorio
resultado = somar(1,2,3,4,5)
print(resultado)

"""LISTAS - tudo que foi feito com as tuplas, serve também para as listas, tendo em vista que as tuplas não podem ser alteradas, mas as listas podem ser alteradas.

"""

alunos = ['Mario', 'Luigi', 'Yoshi', 'Koopa']
alunos[0] = 'Super Mário' #Acrescentei elemento à lista
print(alunos)
#remover elementos
alunos.remove('Super Mário')
print(alunos)
#Inserindo elementos na lista
alunos.insert(2, 'Toad')
print(alunos)
alunos.append("Bowser") #append vai inserir o elemento, porém no final da lista
print(alunos)

alunos = ['Mario', 'Luigi', 'Yoshi', 'Koopa']
for aluno in alunos:
    for letra in aluno:
        print(letra, end=". ")

"""Exercícios Listas e Tuplas Aula 10.
1) Crie um programa que dada uma lista de número diga quais são positivos e quais são negativos:
"""

#Ler os dados
listaNumeros = [] # Para indexar elementos à lista, sem ter problemas, cria-se uma lista vazia para que possamos indexar, a posteiori, valores (digitados pelo usuário) a ela
total = int(input("Digite quantos valores terá a sequência: "))
for i in range(total):
    listaNumeros.append(int(input("Digite o próximo valor: ")))
contPositivos = 0
contNegativos = 0
contZero = 0

for num in listaNumeros:
    if num < 0:
        contNegativos += 1
    elif num > 0:
        contPositivos += 1
    else:
        num == 0
        contZero += 1
print(f"Os positivos são {contPositivos}. Os negativos são {contNegativos}. O número 'zero' foi digitado {contZero} vez(es).")

#Forma alternativa de ler os valores
listaNumero = []
inicial = input("Digite uma sequência numérica e, caso queira sair, escreva 'fim': ")

while inicial != 'fim':
    listaNumero.append(int(inicial))
    inicial = input("") # Caso não queira digitar texto para o usuário, pode deixar uma string vazia, como neste caso.

contPositivos = 0
contNegativos = 0
contZero = 0

for num in listaNumeros:
    if num < 0:
        contNegativos += 1
    elif num > 0:
        contPositivos += 1
    else:
        num == 0
        contZero += 1
print(f"Os positivos são {contPositivos}. Os negativos são {contNegativos}. O número 'zero' foi digitado {contZero} vez(es).")

"""2) Crie um programa que informe qual é o maior e o menor número de uma lista:


"""

lista = []
while True:
    try:
        inicial = input("Deseja digitar os valores s/n ?").lower()
        if inicial == 'n':
            print("Encerrando...")
            break
        else:
            lista.append(int(input("Digite o valor: ")))
    except:
        continue

try:
    print(f"O valor máximo da lista é o número: {max(lista)}")# função que retorna o maior número da lista
    print(f"O valor mínimo da lista é o número: {min(lista)}")# fução que retorna o menor valor de uma lista
    print(f"A soma de todos os elementos da lista é: {sum(lista)}") #Função que soma todos os valores da lista
except:
    print()

"""3 - Escreva uma função que recebe uma lista e substitua todos os valores nulos (0) por 1.

"""

def substitui(lista):
    tam = len(lista) # ler o tamanho da lista
    for i in range(tam): #loop para repetir conforme o tamanho da lista
        if lista[i] == 0: # se a lista na posição i for igual a zero
            lista[i] = 1 # A lista na posição i igual a zero será substituída por 1
minha_lista = [1, 0, 5, 22, 0, 33, 50, 0, 33, 0, 1, 0, 4, 0]
substitui(minha_lista)
print(minha_lista)

"""Somar os digitos de um numero inteiro:"""

soma = 0
a = int(input("Digite um número inteiro: "))
b = str(a) #Transformo em str para poder usar posição. Ex: "b[1] = 2"
for i in range(len(b)):
        soma += int(b[i])
print(f"A soma dos digitos do número inteiro digitado é: {soma}")

"""Conjuntos e Dicionários - coleção de dados. O conjunto lembra a forma como trabalhamos na matemática e não existe repetição, pois ou o elemento está nele ou não está. Também não existe o conceito de posição, como nas tuplas e nas listas.


"""

#Parenteses representam tuplas (1, 3, 'carro', 4, 10, 'sorvete')
#Colchetes listas [2, 4, 10, 'maçã', 3]
#chaves representam conjuntos {1, 3, 4, 5, 6,}

pares = {2, 4, 6, 8, 10}
ímpares = {1, 3, 5, 7, 9}
primos = {2, 3, 5, 7}
compostos = {4, 6, 8, 9}

#Unir
#pares.union(ímpares)
#print(pares)
#intersecção
print(pares.intersection(primos))

#Verificações do tipo if
pares = {2, 4, 6, 8, 10}
ímpares = {1, 3, 5, 7, 9}
primos = {2, 3, 5, 7}
compostos = {4, 6, 8, 9}
if 7 in primos:
    print("7 é primo")
if not 8 in primos:
    print("8 não é primo")

"""O Dicionário, dentro do Python, é um tipo especial de conjunto:"""

jogo = {'Nome' : 'Super Mário', 'Desenvolvedora' : 'Nintendo', 'Ano' : '1990'} # é conjunto porque para a chave nome, p. ex, tem-se armazenado o valor 'Super'.
# Aqui acessa a informação pela posição Nome, Ano, Desenvolverdora e Ano. 3 informações indexadas à variável jogo
print(jogo['Nome'])
jogo['Gênero'] = 'Aventura' # Adicionando chave com valor ao dicionário
print(jogo)
#imprimindo as chaves
print(jogo.keys())

#Imprimindo os valores
jogo.values()

#Imprimindo os itens
jogo.items()

lista_jogos = []
jogo1 = {'Nome' : 'Super Mário', 'Videogame' : 'Sness', 'Ano' : 1990}
jogo2 = {'Nome' : 'Mário Kart 64', 'Videogame' : 'N64', 'Ano' : 1998}
jogo3 = {'Nome' : 'Pokemon Yellow', 'Videogame' : 'Gameboy', 'Ano' : 1999}
lista_jogos = [jogo1,jogo2,jogo3]
print(lista_jogos[1]['Nome']) # acessando o elemento
#Atualizando informação dentro da lista
lista_jogos[2]['Ano']=1998
print(lista_jogos[2])

"""Dicionário Exercício - Crie um dicionário das duas listas abaixo:
Chaves ['Dez', "Vinte", 'Trinta']
Valores [10, 20, 30]

"""

chaves = ['Dez', "Vinte", 'Trinta']
valores = [10,20,30]

meuDicionario = {}
tam_chaves = len(chaves)
for i in range(tam_chaves):
    meuDicionario[chaves[i]] = valores[i]
print(meuDicionario)

"""
Estrutura While Udemy prof Nélio"""

soma = 0
x = int(input('Digite um número enquanto quiser somar, e zero para finalizar: '))
while x != 0:
  soma += x #acumula a variável x dentro da soma
  x = int(input('Digite outro número: '))
print('Soma = ', soma)

"""Estrutura for Udemy prof Nélio"""

for i in range(0, 5, 2): #construção básica
  print(i)

"""Ler valor inteiro N e depois N números inteiros. Ao final, mostra a soma dos N números lidos."""

N = int(input("Quantos números serão digitados? "))

soma = 0 #variável acumuladora
for i in range(0, N):
  x = int(input("Digite um número: "))#repete N vezes
  soma = soma + x #Repete N vezes

print("A soma é igual:", soma)

"""Lista exemplo Udemy prof Nélio:
Fazer um programa que lê um número positivo N, (máximo = 10), depois ler N números quaisquer e armazená-los em um vetor. Em seguida, mostrar na tela todos os elementos do vetor.

"""

N = int(input("Quantos números serão digitados? "))
vet = [0 for x in range(N)] #cria o vetor conforme o que for digitado pelo usuário na variável N, bem como determina seu tamanho (inicio e fim)
for i in range(0, N):
  vet[i] = float(input("Digite um número: "))
print()
print("Números digitados:")
for i in range(0, N):
  print(f"{vet[i]:.1f}")

"""Rock - Papper - Scissors game"""

import random
import time

header = "=" * 100
texto = "Welcome to the Rock - Papper - Scissors game"
print(header)
print(texto.upper().center(len(header)))
print(header)

rock = '''
    _______
---'   ____)
      (_____)
      (_____)
      (____)
---.__(___)
'''

paper = '''
    _______
---'   ____)____
          ______)
          _______)
         _______)
---.__________)
'''

scissors = '''
    _______
---'   ____)____
          ______)
       __________)
      (____)
---.__(___)
'''

print("0", rock)
print()
print("1", paper)
print()
print("2", scissors)
print()

game_images = [rock, paper, scissors]




while True:

    try:

        computer_choice = random.randint(0, 2)

        x = int(input("What do you choose? Type 0 for Rock, 1 for Paper or 2 for Scissors and 3 to shut it dowm. "))

        if x == 3:

            print(f"You chose {x}, so I will shut myself down. See you later, bye!")
            time.sleep(3)
            break

        elif x != 0 and x != 1 and x != 2:
            time.sleep(2)
            print("You chose:", x, game_images[x])
            print("Computer chose:", game_images[computer_choice])
            print("Wrong! You lose!")

    #Condicionais para variável x == 0

        elif x == 0 and computer_choice == 0:
            time.sleep(1)
            print("You chose:", x, game_images[x])
            print("Computer chose:", game_images[computer_choice])
            print("Draw!")


        elif x == 0 and computer_choice == 1:
            time.sleep(1)
            print("You chose:", x, game_images[x])
            print("Computer chose:", computer_choice, game_images[computer_choice])
            print("You lose!")

        elif x == 0 and computer_choice == 2:
            time.sleep(1)
            print("You chose:", x, game_images[x])
            print("Computer chose:", computer_choice, game_images[computer_choice])
            print("You win!")

        #Condicionais para variável x == 1

        elif x == 1 and computer_choice == 0:
            time.sleep(1)
            print("You chose:", x, game_images[x])
            print("Computer chose:", computer_choice, game_images[computer_choice])
            print("You win!")
            time.sleep(1)

        elif x == 1 and computer_choice == 1:
            time.sleep(1)
            print("You chose:", x, game_images[x])
            print("Computer chose", computer_choice, game_images[computer_choice])
            print("Draw!")

        elif x == 1 and computer_choice == 2:
            time.sleep(1)
            print(f"You chose: {x}, {game_images[x]}")
            print("Computer chose:", computer_choice, game_images[computer_choice])
            print("You lose!")

        #Condicionais para variável x == 2

        elif x == 2 and computer_choice == 0:
            time.sleep(1)
            print("You chose:", x, game_images[x])
            print("Computer chose:", computer_choice, game_images[computer_choice])
            print('You lose!')

        elif x == 2 and computer_choice == 1:
            time.sleep(1)
            print("You chose:", x, game_images[x])
            print("Computer chose:", computer_choice, game_images[computer_choice])
            print("You win!")

        elif x == 2 and computer_choice == 2:

            time.sleep(1)
            print("You chose:", x, game_images[x])
            print("Computer chose:", computer_choice, game_images[computer_choice])
            print("Draw!")

    except:
            print("Invalid data!")
            continue

"""Fatorial com laço while"""

num = int(input("digite um número inteiro: ")) #recebe o numero do usuário
fatorial = num
contador = 1 #variável acumuladora

while (num - contador) > 1:
  fatorial = fatorial * (num - contador)
  contador += 1
print("{0}! = {1} ".format(num, fatorial))

"""Listas de Listas - Udemy - prof Nélio

Quantas linhas terá a matriz? 2
Quantas colunas vai ter a matriz? 3


"""

m = int(input("Quantas linhas vai ter a matriz? "))
n = int(input("Quantas colunas vai ter a matriz? "))

mat = [[0 for x in range(n)] for x in range(m)] # primeiro range = número de colunas e o segundo = número de linhas
#abaixo estrutura for para percorrer as linhas e dentro dela outro for para percorrer as colunas
for i in range(0, m): #percorre as linhas
  for j in range(0, n):#percorre as colunas
    mat[i][j] = int(input(f"Elemento [{i},{j}]: ")) #estrutura que marca as posições i e j segundo o digito do usuário
print() #print vazio para saltar linha
print("Matriz digitada: " )
#estrutua for para impressão da matriz percorrendo, de novo, as linhas e as colunas
for i in range(0, m):
  for j in range(0, n):
    print(f"{mat[i][j]} ", end="")
  print()

# 🚨 Don't change the code below 👇
student_heights = input("Input a list of student heights ").split()
for n in range(0, len(student_heights)):
  student_heights[n] = int(student_heights[n])
# 🚨 Don't change the code above 👆


#Write your code below this row 👇
total_height = 0
for heigth in student_heights:  #how sum function works
  total_height += heigth


#How len function works:
number_of_students = 0
for students in student_heights:
  number_of_students += 1

average = total_height / number_of_students
print("{:.0f}".format(average))

lista_produtos = ['fogão', 'panela', 'flavourstone', 'forno microondas', 'torradeira']
for prod in lista_produtos:
  print(prod.capitalize()) #função que coloca a primeira letra maíúscula

preço = [10, 10, 200, 50, 300]
for i in preço:
  imposto = i * 0.1
  print(imposto)

produtos = {
    "facas": 10,
    "garfo": 10,
    "panela": 200,
    "frigideira": 50,
    "flavourstone": 300,
}

for produto in produtos:
  print(produto)
  print(produtos[produto])#para imprimir o valor do item no dicionário

with open("vendasloja.txt", "r" ) as arquivo:
   texto = arquivo.read()
lista_texto = texto.split("\n") #como o txt não é uma lista, usa-se este comando para separá-lo em itens.
faturamento = 0
#excluir a primeira linha
lista_texto = lista_texto[1:]
#para cada linha do meu arquivo, eu quero
#somar o valor depois do ponto e vírgula
for linha in lista_texto:
  posição_pv = linha.find (";") #acha o ponto e vírgula no texto.
  valor = float(linha[posição_pv+1 : ]) #posição do ponto e vírgula + 1, até o final. encontra o nummero para a soma.
  faturamento += valor

print(faturamento)

"""Udemy - Maior Número da lista usando laço for. Não usar função max() e min()."""

# 🚨 Don't change the code below 👇
student_scores = input("Input a list of student scores ").split()
for n in range(0, len(student_scores)):
  student_scores[n] = int(student_scores[n])
print(student_scores)
# 🚨 Don't change the code above 👆

#Write your code below this row 👇
highest_score = 0
for score in student_scores:
    if score > highest_score:
        highest_score = score
print(f"The highest score in the class is: {highest_score}")

"""Instructions
You are going to write a program that automatically prints the solution to the FizzBuzz game.

Your program should print each number from 1 to 100 in turn.

When the number is divisible by 3 then instead of printing the number it should print "Fizz".

When the number is divisible by 5, then instead of printing the number it should print "Buzz".`

  And if the number is divisible by both 3 and 5 e.g. 15 then instead of the number it should print "FizzBuzz"
"""

#Write your code below this row 👇
for number in range(1, 101):
    if number % 3 == 0 and number % 5 == 0:
        print("FizzBuzz")
    elif number % 3 == 0:
        print("Fizz")
    elif number % 5 == 0:
        print("Buzz")
    else:
        print(number)

"""Aula 4 - Uninter - Logica de Programação e Algoritmo em Python - Laço While.

Exercício - Escrever um algoritmo que imprima na tela somente valores dentro de um intervalo especificado pelo usuário e que sejam números pares:
"""

x = int(input("Escreva o intervalo: "))
y = 0
while y < x:
  print (y)
  y += 2
print(y)

inicio = int(input("Digite o inicio: "))
fim = int(input("Digite o fim: "))
x = inicio
while x <= fim:
  if (x % 2 == 0): # modo da divisão para verificar se o numero é par
    print(x)
  x += 1 #observar que esta identação está identada ao while e nao ao if - verifica de um em 1 ate o fim se é par

"""Escreva um algoritmo que calcule a média de notas em determinada disciplina, assumindo que a nota final é a média aritmética dentre 5 notas digitadas."""

#Precisa-se de uma variável para somar os valores das 5 médias.
#Outra variável para contar, dizer que foi até 5.
#Após, faça a média aritmética somando as notas e dividindo pelo numero 5(são 5 notas)
x = int(input("Quantas notas serão somadas? "))
soma = 0
cont = 1
while cont <= x:
  y = float(input("Digite a {}ª nota: ".format(cont)))
  soma += y
  cont += 1
media = soma / cont #cont aqui neste caso corresponde ao número da variável x.
print("A média final é: {:.2f}".format(media))

"""Validando dados de entrada - Crie um algoritmo que valide dados de entrada que sejam números inteiros e positivos. Qualquer valor diferente deve ser rejeitado e um novo valor deve ser digitado."""

x = int(input("Digite um número inteiro positivo: "))
while x <= 0:
  x = int(input("Digite um valor maior do que zero: "))
print("Voce digitou {}. Encerrando o programa...".format(x))

"""Interrompendo um loop com break.
Escreva um algoritmo que fique recebendo frases ou palavras digitadas pelo usuário. Encerre o algoritmo quando a palavra sair for digitada.
"""

print("Digite a mensagem que irei repeti-la para você: ")
print('Se quiser encerrar, digite "sair".')
while True:
  texto = input('')
  print(texto)
  if texto == 'sair':
    break
print("Encerrando o programa!")

"""Instrução - continue: serve para que se volte ao começo do laço, independentemente do estado da variável de controle da condicional. Assim sendo, escreva um algoritmo que realize login em um sistema, sendo que o usuário deva informar seu nome e sua senha.




"""

while True:
  nome = input("Digite seu nome: ")
  if nome != 'Vitor':
    continue #caso a condição seja falsa, volta para o começo do laço
  senha = int(input("Digite sua senha: "))
  if senha == 649543: # se a condição for verdadeira, encerra o loop, mas, se nao for, reinicia o loop.
    break
print("Acesso concedido!")

"""Valores thruthy e Falsey:"""

nome = '' #string vazia significa false, assim como numero 0 (int ou float).
while not nome: # tornou a condição verdadeira, pois o not transformou a condição falsa em verdadeira como se fosse while True
  nome = input("Digite seu nome: ") # ao digitar o nome, a string nao ficará vazia, portanto, se torna True.
valor = int(input("Digite um número qualquer: "))
if valor: #qualquer valor acima de zero será tratado como True e vai para o print
  print("Você digitou um valor diferente de zero.")
else:
  print("Você digitou zero.")

"""Estrutura de repetição "for" Uninter - aula 4"""

for i in range(6):
  print(i)

"""Escreva um algoritmo que calcule a média dos números pares de 1 até 100 (1 e 100 inclusos), usando o laço "for"."""

soma = 0
qtd = 0
for i in range(1,101):
  if (i % 2 == 0):
    soma += i # soma todos os números pares de 1 a 100, cujo resultado é: 2.550
    qtd += 1 #soma a quantidade de numeros pares, cujo resultado é: 50
media = (soma / qtd) #cálculo da média
print("A média dos números pares de 1 até 100 é: {}".format(media))

"""Estruturas de repetição aninhadas: não existe limites e pode-se misturar "while" com "for". Escreva um algoritmo que calcule a tabuada de todos os números de 1 até 10, e, para cada número, calcule a tabuada multiplicando-o pelo intervalo de 1 até 10:

"""

# com 2 while
tabuada = 1
while tabuada <= 10:
  print('Tabuada do {}'.format(tabuada)) #laço externo
  i = 1
  while i <= 10: #Laço interno
    print('{} x {} = {}'.format(tabuada, i, tabuada * i))
    i += 1 # variável iteradora do 2 while - variável iteradora do laço externo
  tabuada += 1 # variável iteradora do 1 while - variável iteradora do laço interno

# com 2 "for"
for tabuada in range(1, 11):
  print("Tabuada do {}:".format(tabuada))
  for i in range(1, 11):
    print('{} x {} = {}.'.format(tabuada, i, tabuada * i))

# "while" + "for"
tabuada = 1
while tabuada <= 10:
  print('Tabuada do {}'.format(tabuada)) #laço externo
  for i in range(1, 11):
    print('{} x {} = {}.'.format(tabuada, i, tabuada * i))
  tabuada += 1

import time
# for" + "While" ao contrario do código acima
for i in range(1, 11):
  print("Tabuada do {}:".format(i))
  tabuada = 1
  while tabuada <= 10:
    print("{} x {} = {}.".format(tabuada, i, tabuada * i))
    tabuada += 1
    time.sleep(1)

"""Didática tech - crie um algortimo, por meio do laço while, para calcular o fatorial de um número que o usuário informou.

"""

import time
numero = int(input("Digite um número inteiro positivo para que seja calculado o seu fatorial: ")) # pega o valor inteiro digitado pelo usuário
contador = 1
fatorial = numero
while (numero - contador) > 1: # checa se o número digitado menos (-) o contador é maior do que 1
  fatorial = fatorial * (numero - contador) # fatorial é o numero do usuário, (x vezes) o numero digitado pelo usuário menos (-) o contador
  contador += 1 # controle de iteração
print("O fatorial de {}! é: {}".format(numero, fatorial))
time.sleep(1)

"""Udemy - Password generator"""

#Password Generator Project
import random
import string
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
symbols = ['!', '#', '$', '%', '&', '(', ')', '*', '+']

print("Welcome to the PyPassword Generator!")
nr_letters = int(input("How many letters would you like in your password?\n"))
nr_symbols = int(input(f"How many symbols would you like?\n"))
nr_numbers = int(input(f"How many numbers would you like?\n"))
random_letters = ''.join(random.choices(letters, k=nr_letters))
random_symbols = ''.join(random.choices(symbols, k=nr_symbols))
random_numbers = ''.join(random.choices(numbers, k=nr_numbers))
easy_password = random_letters + random_symbols + random_numbers
total = nr_letters + nr_symbols + nr_numbers
hard_password = ''.join(random.sample(easy_password, k=total))


print(f"Your easy password is: {easy_password}")
print(f"Your hard password is: {hard_password}")
#Eazy Level - Order not randomised:
#e.g. 4 letter, 2 symbol, 2 number = JduE&!91
#Hard Level - Order of characters randomised:
#e.g. 4 letter, 2 symbol, 2 number = g^2jk8&P

# Vitor's password generator
import random
import string
choice = int(input("Choose the number of digits you want: "))
random = ''.join([random.choice(string.ascii_letters + string.digits ) for n in range(choice)])
print(f"your password is :{random}")

"""Gerador de senhas - Udemy"""

#Password Generator Project
import random
import string
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
symbols = ['!', '#', '$', '%', '&', '(', ')', '*', '+']

print("Welcome to the PyPassword Generator!")
nr_letters = int(input("How many letters would you like in your password?\n"))
nr_symbols = int(input(f"How many symbols would you like?\n"))
nr_numbers = int(input(f"How many numbers would you like?\n"))





#Eazy Level - Order not randomised:
#password = ""
#nr_letters = 4 supondo sendo 4 o digitado pelo usuário
#for char in range(1, nr_letters + 1):
 # password += random.choice(letters)

#for char in range(1, nr_symbols + 1):
 # password += random.choice(symbols)

#for char in range(1, nr_numbers + 1):
 # password += random.choice(numbers)





#e.g. 4 letter, 2 symbol, 2 number = JduE&!91
#Hard Level - Order of characters randomised:
password_list = []

for char in range(1, nr_letters + 1):
  password_list.append(random.choice(letters))

for char in range(1, nr_symbols + 1):
  password_list += random.choice(symbols)

for char in range(1, nr_numbers + 1):
  password_list += random.choice(numbers)

random.shuffle(password_list)
password = ""
for char in password_list:
  password += char

print(f"Your password is: {password}")



#e.g. 4 letter, 2 symbol, 2 number = g^2jk8&P

"""Funções - Udemy - 100 days of code - O primeiro passo é definir a função, cuja finalidade é especificar o que ela deve fazer e fazemos isso usando a palavra chave "def", seguida de um nome "nome_função", parênteses () e dois pontos :, como especificado no exemplo em código abaixo. Posteriormente, de forma identada vinda após os dois pontos, coloca(m)-se a(s) linha(s) de código que determinarão o que essa função executará quando acionada. Para "chamar" a função, isto é, acioná-la, basta somente digitar o seu nome seguido por parênteses. Ex: my_function()."""

#exemplo primario de como criar uma função
def my_function():
  x = 1
  while x <= 5:
    print(x)
    x += 1

my_function()

"""Projeto Udemy - Jogo da forca:

"""

import random
import time
print('''
+---+
  |   |
  O   |
 /|\  |
 / \  |
      | ''')
print()
#Step 1

word_list = ["ardvark", "baboon", "camel"]

#TODO-1 - Randomly choose a word from the word_list and assign it to a variable called chosen_word.

chosen_word = random.choice(word_list)

#TODO-2 - Ask the user to guess a letter and assign their answer to a variable called guess. Make guess lowercase.
guess = input("Guess a letter: ").lower()

#TODO-3 - Check if the letter the user guessed (guess) is one of the leters in the chosen_word.
for letter in chosen_word:
    if letter == guess:
        print("Right")
    else:
        print("Wrong")
        time.sleep(2)
print()
print(f"The chosen word was {chosen_word}")

"""2 - parte do código:"""

#Step 2

import random
word_list = ["ardvark", "baboon", "camel"]
chosen_word = random.choice(word_list)

#Testing code
print(f'Pssst, the solution is {chosen_word}.')

#TODO-1: - Create an empty List called display.
#For each letter in the chosen_word, add a "_" to 'display'.
#So if the chosen_word was "apple", display should be ["_", "_", "_", "_", "_"] with 5 "_" representing each letter to guess.
display = []
word_length = len(chosen_word)

for _ in range(word_length):
    display += "_"
print(display)
print()
print()

guess = input("Guess a letter: ").lower()

#TODO-2: - Loop through each position in the chosen_word;
#If the letter at that position matches 'guess' then reveal that letter in the display at that position.
#e.g. If the user guessed "p" and the chosen word was "apple", then display should be ["_", "p", "p", "_", "_"].
for position in range(word_length):
    letter = chosen_word[position]
    if letter == guess:
        display[position] = letter

#TODO-3: - Print 'display' and you should see the guessed letter in the correct position and every other letter replace with "_".
#Hint - Don't worry about getting the user to guess the next letter. We'll tackle that in step 3.

print(display)

"""3 parte do código:"""

#Step 3
import random
word_list = ["aardvark", "baboon", "camel"]
chosen_word = random.choice(word_list)
word_length = len(chosen_word)
#Testing code
print(f'Pssst, the solution is {chosen_word}.')
#Create blanks
display = []
for _ in range(word_length):
    display += "_"

#TODO-1: - Use a while loop to let the user guess again. The loop should only stop once the user has guessed all the letters in the chosen_word and 'display' has no more blanks ("_"). Then you can tell the user they've won.
end_of_game = False

while not end_of_game: # o fim só ocorrerá quando a variável display não tiver mais "blanks".
    guess = input("Guess a letter: ").lower()
    #Check guessed letter
    for position in range(word_length):
        letter = chosen_word[position]
        print(f"Current position: {position}\n Current letter: {letter}\n Guessed letter: {guess}")
        if letter == guess:
            display[position] = letter
    print(display)

    if "_" not in display:
        end_of_game = True
        print("You win.")

"""Parte 4 do codigo:"""

#Step 4

import random

stages = ['''
  +---+
  |   |
  O   |
 /|\  |
 / \  |
      |
=========
''', '''
  +---+
  |   |
  O   |
 /|\  |
 /    |
      |
=========
''', '''
  +---+
  |   |
  O   |
 /|\  |
      |
      |
=========
''', '''
  +---+
  |   |
  O   |
 /|   |
      |
      |
=========''', '''
  +---+
  |   |
  O   |
  |   |
      |
      |
=========
''', '''
  +---+
  |   |
  O   |
      |
      |
      |
=========
''', '''
  +---+
  |   |
      |
      |
      |
      |
=========
''']

end_of_game = False
word_list = ["ardvark", "baboon", "camel"]
chosen_word = random.choice(word_list)
word_length = len(chosen_word)

#TODO-1: - Create a variable called 'lives' to keep track of the number of lives left.
#Set 'lives' to equal 6.

#Testing code
print(f'Pssst, the solution is {chosen_word}.')

#Create blanks
display = []
for _ in range(word_length):
    display += "_"

while not end_of_game:
    guess = input("Guess a letter: ").lower()

    #Check guessed letter
    for position in range(word_length):
        letter = chosen_word[position]
        # print(f"Current position: {position}\n Current letter: {letter}\n Guessed letter: {guess}")
        if letter == guess:
            display[position] = letter

    #TODO-2: - If guess is not a letter in the chosen_word,
    #Then reduce 'lives' by 1.
    #If lives goes down to 0 then the game should stop and it should print "You lose."

    #Join all the elements in the list and turn it into a String.
    print(f"{' '.join(display)}")

    #Check if user has got all letters.
    if "_" not in display:
        end_of_game = True
        print("You win.")

    #TODO-3: - print the ASCII art from 'stages' that corresponds to the current number of 'lives' the user has remaining.

"""Aula prática 4 - Uninter"""

#comparativo while e for
#while:
x = 1 # valor inicial do iterador while
while(x < 6): #entre parêntese está o valor final do iterador
    print(x)
    x = x + 1 #passo do iterador
#laço for equivalente
for i in range(1, 6, 1): # O primeiro 1 é o valor inicial do iterador. O número 6 é o alcanse, porém vai ate 5. O ultimo 1, é o passo do iterador, de 1 em 1.
    print(i)

"""Realize a sequencia de print com for e while:
A) Inteiros de 3 até 12, com 12 incluso:
B) Inteiros de 0 até 9, excluindo 9, com passo de 2.
"""

# A com laço for:

for i in range(3, 13, 1):
    print(i)

# A com laço while:

x = 3
while (x <= 12):
    print(x)
    x = x + 1

# B com laço for:
for i in range(0, 9, 2):
    print(i)

#B com laço while:

x = 0
while (x < 9):
    print(x)
    x = x + 2

"""Escreva um algoritmo que leia  dois valores numéricos e que pergunte ao usuário qual operação ele deseja realizar: adição, subtração, multiplicação ou divisão e sair. Exiba na tela o resultado da operação desejada. Repita até que a opção de saída seja digitada."""

titulo = 'calculadora'
print(f"{titulo.upper():-^50}")
def full_op():
    while True:
        try:
            valor_1 = int(input("Digite o primeiro valor para a operação: "))
            valor_2 = int(input("digite o segundo valor para a operação: "))
            break
        except:
            print("Digite somente números válidos, animal!")

    op = input("Qual operação deseja realizar? \nDigite: \n(*) para multiplicação; \n(/) para divisão; \n(+) para adição; \n(-) para subtração;\n(s) para sair.\n")
    if op == 's':
        print(f"Voce digitou '{op}'. Encerrando!")

    print()

    while 's' not in op:
        op_mul = valor_1 * valor_2
        op_div = (valor_1) / (valor_2)
        op_sub = (valor_1 - valor_2)
        op_soma = (valor_1 + valor_2)
        if op == '*':
            print("{} x {} = {}".format(valor_1, valor_2, op_mul))

            op = input("Qual operação deseja realizar? \nDigite: \n(*) para multiplicação; \n(/) para divisão; \n(+) para adição; \n(-) para subtração;\n(s) para sair.\n")
            print()
            if op == 's':
                print(f"Voce digitou '{op}'. Encerrando!")
                break
                valor_1 = int(input("Digite o primeiro valor para a operação: "))
                valor_2 = int(input("digite o segundo valor para a operação: "))
        elif op == '/':
            print("{} / {} = {}".format(valor_1, valor_2, op_div))
            print()
            op = input("Qual operação deseja realizar? \nDigite: \n(*) para multiplicação; \n(/) para divisão; \n(+) para adição; \n(-) para subtração;\n(s) para sair.\n")
            print()
            if op == 's':
                print(f"Voce digitou '{op}'. Encerrando!")
                break
            valor_1 = int(input("Digite o primeiro valor para a operação: "))
            valor_2 = int(input("digite o segundo valor para a operação: "))
        elif op == '-':
            print("{:.0f} - {:.0f} = {:.0f}".format(float(valor_1), float(valor_2), op_sub))
            print()
            op = input("Qual operação deseja realizar? \nDigite: \n(*) para multiplicação; \n(/) para divisão; \n(+) para adição; \n(-) para subtração;\n(s) para sair.\n")
            print()
            if op == 's':
                print(f"Voce digitou '{op}'. Encerrando!")
                break
            valor_1 = int(input("Digite o primeiro valor para a operação: "))
            valor_2 = int(input("digite o segundo valor para a operação: "))
        elif op == '+':
            print("{} + {} = {:.2f} ".format(valor_1, valor_2, op_soma))
            print()
            op = input("Qual operação deseja realizar? \nDigite: \n(*) para multiplicação; \n(/) para divisão; \n(+) para adição; \n(-) para subtração;\n(s) para sair.\n")
            print()
            if op == 's':
                print(f"Voce digitou '{op}'. Encerrando!")
                break
            else:
                valor_1 = int(input("Digite o primeiro valor para a operação: "))
                valor_2 = int(input("digite o segundo valor para a operação: "))
full_op()

"""Escreva um algoritmo que que leia um valor e que imprima a quantidade de cédulas necessárias para pagar esse mesmo valor. Para simplificar, vamos trabalhar apenas com valores inteiros e com cédulas de R$ 100, R$ 50, R$ 20, R$ 10, R$ 5 e R$ 1."""

valor = int(input("Digite o valor que dejesa retirar: "))

while True:
    if valor >= 100:
        cedulas_100 = valor // 100
        valor = valor - cedulas_100 * 100
        print("Cedulas de 100: {} ".format(cedulas_100))
        if not valor:
            break
    if valor >= 50:
        cedulas_50 = valor // 50
        valor = valor - cedulas_50 * 50
        print("Cedulas de 50: {} ".format(cedulas_50))
        if not valor:
            break
    if valor >= 20:
        cedulas_20 = valor // 20
        valor = valor - cedulas_20 * 20
        print("Cedulas de 20: {} ".format(cedulas_20))
        if not valor:
            break
    if valor >= 10:
        cedulas_10 = valor // 10
        valor = valor - cedulas_10 * 10
        print("Cedulas de 10: {} ".format(cedulas_10))
        if not valor:
            break
    if valor >= 5:
        cedulas_5 = valor // 5
        valor = valor - cedulas_5 * 5
        print("Cedulas de 5: {} ".format(cedulas_5))
        if not valor:
            break
    if valor:
        cedulas_1 = valor
        print("Cédulas de 1: {}".format(cedulas_1))
        break

"""Um cinema cobra preço diferente para os ingressos de acordo coma idade de uma pessoa. Se a pessoa tiver menos de 3 anos de idade, o ingresso será gratuito. Se tiver entre 3 e 12 anos, custará 15, se tiver mais de 12 anos custará 30. Escreva um laço que vc pergunte a idade aos usuários e lhes informe o preço do ingresso. Encerre o laço qdo o usuário digitar "sair". Após o laço, apresente na tela o total de pessoas que compraram ingressos, o total de dinheiro arrecadado e a média de idade das pessoas"""

total = 0
dinheiro = 0

while True:
    idade = input("Digite a sua idade: ")
    if idade == 's':
        break
    idade = int(idade)
    total += 1 # colocamos o incremento aqui antes do break, porque conta-se o total de pessoas e antes do break poderia contar 'sair' como pessoa.
    if idade < 3:
        ingresso = 0
    else:
        if idade > 12:
            ingresso = 30
        else:
            ingresso = 15
    dinheiro = ingresso + dinheiro #incrementa os valores dos ingressos na variável dinheiro.

média = dinheiro / total

print("Total de pessoas: {}".format(total))
print("Total arrecadado: {:.2f}".format(dinheiro))
print("Média arrecada: {:.2f}".format(média))

"""Um cinema cobra preço diferente para os ingressos de acordo coma idade de uma pessoa. Se a pessoa tiver menos de 3 anos de idade, o ingresso será gratuito. Se tiver entre 3 e 12 anos, custará 15, se tiver mais de 12 anos custará 30. Escreva um laço que vc pergunte a idade aos usuários e lhes informe o preço do ingresso. Encerre o laço qdo o usuário digitar "sair". Após o laço, apresente na tela o total de pessoas que compraram ingressos, o total de dinheiro arrecadado e a média de idade das pessoas"""

total = 0
dinheiro = 0

while True:
    idade = input("Digite sua idade para continuar ou (s) para sair: " )
    if idade == 's':
        break
    idade = int(idade)
    total += 1
    if idade < 3:
        ingresso = 0
    else:
        if idade > 12:
            ingresso = 30
        else:
            ingresso = 15
    dinheiro = ingresso + dinheiros

média = dinheiro / total

print("Total de pessoas: {}".format(total))
print("Total arrecadado: {:.2f}".format(dinheiro))
print("Média arrecada: {:.2f}".format(média))

"""Aula 5 Uninter - Função "rotinas".

Função sem retorno;
Função com retornno;
Passagem de parâmetros;
Escopo de variável;
Tratamento de exceções;
Função Lambda (particularidade da linguagem python).
"""

#Exemplo de realce em texto

#print('|', '_' * 10, '|' )
#print('|', '_' * 10, '|' )
#print('     MENU     ')
#print('|', '_' * 10, '|' )
#print('|', '_' * 10, '|' )

#SINTAXE PARA CRIAR A FUNÇÃO EM PYTHON

def realce():
    print('|', '_' * 10, '|' )
    print('|', '_' * 10, '|' )
    print('     MENU     ')
    print('|', '_' * 10, '|' )
    print('|', '_' * 10, '|' )

realce()

"""Passagem de parâmetros em função - parâmetro é(são) dado(s) recebido(s) pela função(ões). O ato de enviar um dado para a função é chamado de passagem de parâmetro."""

#exemplo didático
def realce(s1): # realce é o nome da função. Dentro dos parênteses encontra-se o nome de uma variável que será criada dentro da função e receberá o dado como parâmetro.
    print('|', '_' * 10, '|' )
    print('|', '_' * 10, '|' )
    print(s1)
    print('|', '_' * 10, '|' )
    print('|', '_' * 10, '|' )

realce('     MENU')

"""Passando mais de 1 parâmetro para a função:"""

def sub2(x, y):
    res = x - y
    print(res)
#Programa principal
sub2(5, 7)
sub2(7, 5)
#Também podemos nomear os parâmetros
sub2(y = 5, x = 10)

"""Parâmetros opcionais:"""

def soma3(x, y, z):
    res = x + y + z
    print(res)

"""Escreva uma rotina que cria uma borda ao redor de uma palavra para destacá-la como sendo um título. A rotina deve receber como parâmetro a palavra a ser destacada. O tamanho da caixa de textodeverá ser adaptável de acordo com o tamanho da palavra."""

def borda(s1):
    tam = len(s1)
    #só imprime caso exista algum caractere
    if tam: # teste if - qualquer valor inteiro, numérico e que não for zero, retorna verdadeiro e fará o print.
        print('+', '-' * tam, '+')
        print('|', s1, '|')
        print('+', '-' * tam, '+')

#programa principal
borda("Olá, mundo!")
borda("Lógica de Programação e Algoritmos")

"""Escopo de variáveis: um escopo é a propriedade que determina onde a variável pode ser usada dentro de um programa, ou seja, onde a variável está inserida e pode ser manipulada. Existem 2 tipos de escopo de variáveis: o escopo local e o escopo global. O escopo local, é aquele que ao se criar uma variável dentro de uma função, pré difinida ou recém criada, as variáveis que ali dentro existem, funcionam somente no escopo local, isto é, elas só existem ali dentro e fora do contexto daquela função elas não existe mais. Já a variável global, do programa principal, existe ao longo de todo o programa. Uma variável global, p. ex, existe também em todas as funções invocadas ao longo do programa."""

#Exemplo:
def comida():
    print(ovos)
#Programa principal
ovos = 12 #variável global
comida()

#Outro exemplo:
def comida():
    ovos = 12 #variável local
    bacon() #invoca a função bacon
    print(ovos)

def bacon():
    ovos = 6 # essa variável ovos não é a mesma variável ovos da função acima, embora tenha o mesmo nome.
#Programa principal

comida()

#Ultimo exemplo escopo
def comida():
    ovos = 'variável local de comida' #variável local da função comida
    print(ovos) #print referente à função comida "variável local de comida"

def bacon():
    ovos = "Variável local de bacon" #variável local da função bacon
    print(ovos)
    comida()
    print(ovos)
#Programa principal
ovos = 'variável global' # escopo global = funciona por todo o programa.
bacon()
print(ovos)
#Se a variável local tiver o mesmo nome da variável global, vale para a função a variável dentro dela(local)

"""Instrução Global - Força o nosso programa a não criar uma variável local de mesmo nome e manipular somente a global dentro de uma função. Exemplo:"""

def comida():
    global ovos # Altera a variável no programa principal - 'Instrução global'
    ovos = 'comida'
#Programa principal
ovos = 'global'
comida()
print(ovos)

"""Retorno de valores/parâmetros em Funções:
Conceitualmente - procedimento (procedure) é uma rotina sem retorno.
Função - uma rotina que retorna um dado a quem a invocou.
"""

def soma3(x = 0, y = 0, z = 0):
    res = x + y + z
    return res
# Programa principal
retornado = soma3(1,2,3)
print(retornado)
# Sintaxe alternativa simplificada
print(soma3(1,2,3))
#Formas distintas de armazenar a função em uma variável e utilizá-la como quiser
retornado1 = soma3(4,5,1)
retornado2 = soma3(1,2)
retornado3 = soma3()
print("Somatórios: {}, {} e {}.".format(retornado1, retornado2, retornado3))

"""Escreva uma função para validar um string. Essa função recebe como parâmetro a string, o número mínimo e máximo de caracteres. Retorne verdadeiro se o tamanho da string estiver entre os valores de mínimo e máximo, e falso, caso contrário (elaborado com base em Menezes, s.d)"""

#Exercício 1 valida string - detalhe: valida conforme tamanho e não devido à sua classe
def valida_string(pergunta, min, max):
    s1 = input(pergunta) # variável para ler a string digitada pelo usuário.
    tam = len(s1) #variável para ler o tamanho da string digitada pelo usuário.
    while ((tam < min) or (tam > max)): # laço de repetição inerente à condição estabelecida: a string ter entre 10 a 30 caracteres.
        s1 = input(pergunta) # caso o laço não esteja em condição verdadeira, repetir-se-á o mesmo.
        tam = len(s1)
    return s1 # retorna a string
# Programa principal
x = valida_string("Digite uma string:", 10, 30) # 3 parâmetros da função. O 1 é a pergunta, o 2 é o min e o 3 é o max.
print("Você digitou a string: {}. \n Dado válido. Encerrando o programa...".format(x))

"""Recursos avançados com funções - Tratamento de erros - alguns erros podem ser tratados, como o erro de exceção. Neste tipo de erro, a sintaxe está correta, porém um erro durante a execução do programa ocorre, normalmente devido a um dado digitado de maneira inválida e não tratado durante o programa. Existem inúmeros erros de exceção na linguagem python e estão todas catalogadas na própria documentação do python. As mais comuns são: ZeroDivisionError, ValueError e IndexError. Lista completa: docs.python.org"""

#Exemplo de tratamento de ValueError
while True:
    try: #tenta executa o input abaixo e caso haja exeção, printa abaixo da exceção e volta para o loop.
        x = int(input("Digite um número: "))
        print("Dado válido! Encerrando...")
        break
    except ValueError:
        print("Ooops! Número inválido! Tente novamente.")

#Outro exemplo envolvendo exceção:
def div():
    try:
        num1 = int(input("Digite um número: "))
        num2 = int(input("Digite um número: "))
        res = num1 / num2
    except ZeroDivisionError:
        print("Ooops! Erro de divisão por zero!")
    except:
        print("Algo de errado aconteceu...") # significa que qualquer outro erro inesperado, vai printar a msg abaixo
    else:
        return res
    finally: # finally depois do try significa que sempre irá executar independente de dar exceção ou não.
        print("Executará sempre!")
#Programa principal
print(div())

"""Função como parâmetro de função.
Permite a criação de rotinas bastantes genéricas:
"""

#Imprime um número dado uma condição
def imprime_com_condição(num, fcond): # 3 funções ai dentro. Uma função chamada imprime_com_condição que imprime um número dado uma condição que será calculada por meio de uma função intrínseca ao parâmetro fcond
    if fcond(num): # pega a função "par" e caso seja faz o print
        print(num)

def par(x): # Função para encontrar valor par
    return x % 2  == 0 #retorna o resultado
def ímpar(x): #Função para encontrar valor ímpar
    return not par(x)
#Programa principal
imprime_com_condição(5, par) #substitui o nome fcond, pela função que foi passada como parâmetro "par"

"""Função Lambda: função mais simples e sem nome de linguagem python cuja escrita se dá somente por uma linha. Isto é, podem ser escritas em uma só linha de código e dentro do programa principal."""

#Exemplo de função lambda
res = lambda x: x * x # O parâmetro esta no x antes dos dois pontos":". Depois dos parâmetros segue o cálculo.
print(res(3))
#Outro exemplo
soma = lambda x, y: x + y
print(soma(3, 5))

"""Aula Prática 5 Uninter - Interactive help - manual explicativo de tudo dentro do python. Comando/função via terminal help(). Para sair digite: quit.

Docstring são strings inseridas dentro do nosso codigo python que explicam o funcionamento dele. A string é colocada na primeira linha da definição de uma função.
"""

#Exemplo de criação de docstring:
def soma(x=0, y=0, z=0):
    """ Retorna o somatório de até 3 valores numéricos quaisquer.
    Todos os parâmetros são opcionais.

    x: valor numerico opcional
    y: valor numerico opcional
    z: valor numerico opcional
    """
    return x + y + z
print(soma(3,2))
help(soma)

"""Exercicio - Escreva uma função que calcule o fatorial de um número e retorne seu fatorial. Faça a validação dos dados por meio de outra função, permitindo que só valores inteiros sejam aceitos. Crie o help da sua função."""

def valida_int(pergunta, min, max):
    x = int(input(pergunta))
    while ((x < min) or (x > max)):
        x = int(input(pergunta))
        return x
def fatorial(num):
    """ função que retona o fatorial de um número
    digitado pelo usuário.
    """
    fat = 1
    if num == 0:
        return fat
    for i in range(1,num+1,1):
        fat *= i
    return fat
#Programa principal
x = valida_int('Digite o número para o cálculo fatorial do mesmo: ', 0, 99999)
print('{}! = {}'.format(x, fatorial(x)))

"""Calculadora com função em estrutura de repetição:"""

def soma(n1, n2):
    return n1 + n2
def sub(n1, n2):
    return n1 - n2
def mult(n1, n2):
    return n1 * n2
def sub(n1, n2):
    return n1 - n2
titulo = 'calculadora básica'
print(f"{titulo.upper():-^50}")
print()
while True:
    try:
        op = input("Digite qual operação deseja realizar.\nEscreva: \n\t(*) para multiplicar\n\t(/) para dividir\n\t(-) para subtrair\n\t(+) para somar\n\t(s) para sair ").lower()
        if op == 's':
            print(f"Voce digitou '{op}'. Encerrando o programa!")
            break
        print()
        n_1 = int(input("Digite o 1º número: "))
        n_2 = int(input("Digite o 2º número: "))
        if op == '+':
            resultado = soma(n_1, n_2)
            print("{} + {} = {}".format(n_1, n_2, resultado))
        elif op == '-':
            resultado = sub(n_1, n_2)
            print("{} - {} = {}".format(n_1, n_2, resultado))
        elif op == '*':
            resultado = mult(n_1, n_2)
            print("{} x {} = {}".format(n_1, n_2, resultado))
        elif op == '/':
            resultado = div(n_1, n_2)
            print("{} / {} = {}".format(n_1, n_2, resultado))
    except:
        print("Somente dados válidos, animal de rabo!")

"""Simule encher um balde de 1000ml com um copo de 100ml, tendo uma margem de segurança no copo entre 95, 100 ml."""

from random import randint

CAPACIDADE_MAXIMA_BALDE = 1000
balde = 0

while balde <= CAPACIDADE_MAXIMA_BALDE:
    volume_copo = randint(95, 100)
    print(f"O copo encheu {volume_copo}ml")
    balde += volume_copo
    print(f"O volume do balde é {balde}ml\n")

"""Listas python Academy:"""

lista = [0, 'str', 5.5, []]
for elemento in lista:
    print(f"O elemento atual é {elemento}")

"""Indexação de listas:"""

pares = [2, 4, 6, 8]
impares = [1, 3, 5, 7]
print(pares[0] * impares[0])

#indexação negativa
print(pares[-1])

"""Percorrendo lista com estruturas de repetição"""

import random
alunos = ['joão', 'ana', 'clara', 'josé', 'bento']
#for aluno in alunos:
#    print(f"O nome do aluno é {aluno}")
#for aluno in alunos:
#    nota = randint(0, 10)
#    print(f"A nota do aluno {aluno} é {nota}.")

for aluno in alunos:
    nota_1 = randint(5, 10 )
    nota_2 = randint(4, 9)
    nota_3 = randint(3, 7)

    nota_final = (nota_1 * 0.2) + (nota_2 * 0.3) + (nota_3 * 0.5)
    print(f"A nota final do {aluno} foi: {nota_final}")

import random
alunos = ['joão', 'ana', 'clara', 'josé', 'bento']
notas = [randint(5, 10), randint(5, 10), randint(5, 10), randint(5, 10), randint(5, 10)]
for aluno, nota in zip(alunos, notas):
    print(f"A nota do aluno {aluno} foi: {nota}")

"""Fatiamento de listas - slicing"""

letras = ['a', 'b', 'c', 'd', 'e', 'f']
print(letras[0:3:1])
print(letras[3:6:1])
print(letras[::-1])# Indexação negativa iniciando no final, isto é, inversão da lista.

#O mesmo slicing usando indexação negativa
letras = ['a', 'b', 'c', 'd', 'e', 'f']
print(letras[-6:-3:1])
print(letras[-3: : 1])
print(letras[-1:-4:-1])

#Concatenando listas
letras = ['a', 'b', 'c', 'd', 'e', 'f']
print(letras[0:3:1] + letras[3:6:1])

"""Método append"""

sacola = ['arroz', 'feijão', 'carne', 'farinha']
print(sacola.index('farinha')) # mostra a posição do elemento conforme seu número index - possui 3 parâmetros para buscar em sub lista de uma lista maior
print(sacola.index('farinha', 0, 4))
print(sacola)
sacola.append('Macarrão')# método append adiciona elemento
print(sacola)
sacola.extend(['Maionese', 'ketchup'])#método extend extende a lista a partir de outro iterável
print(sacola)
sacola.insert(0, 'Milho')# método que coloca um elemento conforme a indicação do índice
print(sacola)
sacola.remove('Macarrão')#remove o primeiro elemento igual ao valor passado
print(sacola)
sacola.pop()#remove o elemento retornando-o para que ele possa ser utilizando durante o código/caso o índice não seja especificado, retorna o último elemento
print(sacola) #perceba que retirou o último elemento
sacola.pop(3)
print(sacola)
elemento = sacola.pop(3)
print(elemento)
print(sacola.count('arroz'))
sacola1 = ['arroz', 'feijão', 'carne', 'farinha']
sacola1.sort() # ordena a lista: strings pela ordem alfabética e numeros crescente
print(sacola1)


#sacola.clear() #remove todos os elementos da lista

sacola = ['arroz', 'feijão', 'carne', 'farinha']
sacola.sort(reverse=True) # ordem reversa de ordenação
print(sacola)

sacola = ['arroz', 'feijão', 'carne', 'farinha']
sacola.reverse() # Inverte a ordem da lista
print(sacola)

sacola = ['arroz', 'feijão', 'carne', 'farinha']
copia_sacola = sacola.copy()
print(copia_sacola)

"""Sets e Tuplas - Sets são desordenados e não importa a ordem de adição de elementos dentro de um set. Os itens do set não são indexados e intercambiáveis, não possuem itens duplicados, mas possuem métodos para manipulações de conjuntos. s = {1, 2, 3}. Há tb a função set: s = set({1, 2, 3)}"""

#Manipulação de sets
set_1 = {1,2,3}
print(set_1)
#função padrão python
set_2 = set()
print(set_2)
#Jogando uma lista dentro da função set
lista = [1, 2, 3, 4,]
set_3 = set(lista)
print(set_3)

carteira = {'PETR4', 'CASH3', 'MGLU3', 'BBAS3', 'WEGE3'}
print(f"Carteira inicial {carteira}")
# Método add - adição de valores ao set
carteira.add("ITSA4")
print(f"Após o add {carteira}.")
#Metodo update - atualiza os elementos do set
carteira.update({'PETR4', 'ABEV3', 'RAIZ4'}) # OPETRA4 já existia, portanto ele não é adicionado ao set
print(f'Carteira após update: {carteira}')
# metodos de remoção de itens - Remove - Discard - POP
carteira.discard("PETR4")
print(f'Carteira após discard: {carteira}') # O método discard não lança exceção (erro) se o item nao estiver no set
#Metodo remove
carteira.remove('ABEV3') # se o item não conta no set, o método remove lança uma exceção (erro)
print(f'Carteira após remove: {carteira}')
#Método POP - retira o ultimo elemento do set
item = carteira.pop()
print(f'Item removido: {item}')
print(f'Carteira após pop: {carteira}')
#Método clear limpa o set, remove tudo e deixa vazio
carteira.clear()
print(f'Carteira após o clear: {carteira}')

#Operações matemáticas disponíveis em sets
homens = {'João', 'Joaquim', 'Alberto', 'Antônio', 'Leonardo', 'Victor', 'Kléber', 'Marcelo', 'Alfredo'}
alta_renda = {'Ana', 'Joaquim', 'Joana', 'Antônio', 'Kléber', 'Marcelo', 'Alfredo', 'Carla', 'Adriana'}
print(f"Conjunto de homens: \t{homens}")
print(f'Conjunto de alta renda: {alta_renda}\n{"-" * 180}')
#Interceção - itens que estão em ambos os conjuntos
homens_alta_renda = homens.intersection(alta_renda)
print(f"Conjunto de homens com alta renda: \t{homens_alta_renda}")
print(f'{"-" * 180}')
#Metodo union juntar os dois conjuntos - podemos usar duas formas:
homens_e_alta_renda = homens.union(alta_renda)
homens_e_alta_renda = alta_renda.union(homens)
print(f'Homens e usuários de ambos conjuntos: {homens_e_alta_renda}')
print(f'{"-" * 180}')
#Método da diferença - consegue itens que estão apenas em um dos conjuntos
homens_nao_alta_renda = homens.difference(alta_renda)
alta_renda_nao_homens = alta_renda.difference(homens)
print(f'Homens e usuários com não alta renda: {homens_nao_alta_renda}')
print(f'Usuários alta renda não homens: {alta_renda_nao_homens}')
print(f'{"-" * 180}')
#Método da diferença simétrica - itens que só estão em seus respectivos conjuntos para uní-los. Retira a interceção.
homens_nao_alta_renda_e_mulheres = homens.symmetric_difference(alta_renda)
#homens_nao_alta_renda_e_mulheres = homens.symmetric_difference_update(alta_renda) a diferença é que este altera o conjunto de origem
print(f'Usuários não alta renda homens e mulheres: {homens_nao_alta_renda_e_mulheres}')
print(f'{"-" * 180}')
#método de verificação de pertencimento - se um conjunto esta dentro do outro, se é disjunto, se é um super set, sub set etc.
print(f'Os conjuntos de homens e alta renda são disjuntos? {homens.isdisjoint(alta_renda)}')
print(f'O conjunto de homens é um subconjunto de alta renda? {homens.issubset(alta_renda)}')
print(f'O conjunto de homens é um superconjunto de Alta Renda? {homens.issuperset(alta_renda)}')
print(f'{"-" * 180}')

#Interceção
print(homens & alta_renda) # interceção que substitui o método .intersection

#União
print(homens | alta_renda)

# Diferença
print(homens - alta_renda)

# Diferença simétrica
print(homens ^ alta_renda)

# Tuplas
#lista = [5, 26, 11]
#tupla = (1, 2, 3)
#tupla_2 = tuple(lista)
#print(type(tupla))
#print(tupla)
#print(tupla_2)

#Indexação

tupla = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
print(f'O 5 elemento da tupla é o número: {tupla[4]}')

#Indexação negativa
print(f'O 5 último elemento da tupla é o número: {tupla[-1]}')
print(f'{"-" * 180}')


# Fatiamento - slicing
tupla_slicing = tupla[4:]
print(f'Tupla após fatiamento: {tupla_slicing}')
print(f'{"-" * 180}')

# Alterar valor de tupla
# tupla[0] = 1 #operação inálida - erro

# del tupla[0] - operação inválida - erro

# del tupla exclui a tupla

# Métodos
print(f'A quantidade de elementos iguais a 1 é: {tupla.count(1)}')

print(f'O elemento 10 esta na posição: {tupla.index(10)}')
#iteração
for elemento in tupla:
    print(f'Elemento = {elemento}')

"""Dicionários - Dicts -"""

dicionario = {'nome' : 'Vitor'}
print(dicionario['nome'])

cadastro = {
    'id': 1,
    'nome' : 'João Carlos Silva',
    'filhos' : ['Joana', 'Sarah'],
    'compras' : [
        {
            'id' : 4758,
            'produto' : 'Laptop Gamer',
            'preço' : 2597.99

        }
    ]

}
print(f"O usuário {cadastro['nome']} realizou a seguinte compra: {cadastro['compras'][0]['produto']}") # forma que é bom evitar
#outra forma de fazer o mesmo print, passando uma estrututra para outra variável
notebook_gamer = cadastro['compras'][0]
print(f"O usuário {cadastro['nome']} realizou a seguinte compra: {notebook_gamer['produto']}") #forma visualmente melhor
#Acessando elementos a partir da função get
filhos = cadastro.get('filhos', )
print(f"Print após a função get: {filhos}")
#tratando erro com none
altura = cadastro.get('altura', None) # retorna none caso não exista a chave, portanto, não ocasiona erro de chave(KeyError)
print(altura)